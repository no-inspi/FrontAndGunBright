{"ast":null,"code":";\n\n(function () {\n  /* UNBUILD */\n  function USE(arg, req) {\n    return req ? require(arg) : arg.slice ? USE[R(arg)] : function (mod, path) {\n      arg(mod = {\n        exports: {}\n      });\n      USE[R(path)] = mod.exports;\n    };\n\n    function R(p) {\n      return p.split('/').slice(-1).toString().replace('.js', '');\n    }\n  }\n\n  if (typeof module !== \"undefined\") {\n    var MODULE = module;\n  }\n  /* UNBUILD */\n\n\n  ;\n  USE(function (module) {\n    // Security, Encryption, and Authorization: SEA.js\n    // MANDATORY READING: https://gun.eco/explainers/data/security.html\n    // IT IS IMPLEMENTED IN A POLYFILL/SHIM APPROACH.\n    // THIS IS AN EARLY ALPHA!\n    if (typeof window !== \"undefined\") {\n      module.window = window;\n    }\n\n    var tmp = module.window || module,\n        u;\n    var SEA = tmp.SEA || {};\n\n    if (SEA.window = module.window) {\n      SEA.window.SEA = SEA;\n    }\n\n    try {\n      if (u + '' !== typeof MODULE) {\n        MODULE.exports = SEA;\n      }\n    } catch (e) {}\n\n    module.exports = SEA;\n  })(USE, './root');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n\n    try {\n      if (SEA.window) {\n        if (location.protocol.indexOf('s') < 0 && location.host.indexOf('localhost') < 0 && !/^127\\.\\d+\\.\\d+\\.\\d+$/.test(location.hostname) && location.protocol.indexOf('file:') < 0) {\n          console.warn('HTTPS needed for WebCrypto in SEA, redirecting...');\n          location.protocol = 'https:'; // WebCrypto does NOT work without HTTPS!\n        }\n      }\n    } catch (e) {}\n  })(USE, './https');\n  ;\n  USE(function (module) {\n    var u;\n\n    if (u + '' == typeof btoa) {\n      if (u + '' == typeof Buffer) {\n        try {\n          global.Buffer = USE(\"buffer\", 1).Buffer;\n        } catch (e) {\n          console.log(\"Please `npm install buffer` or add it to your package.json !\");\n        }\n      }\n\n      global.btoa = function (data) {\n        return Buffer.from(data, \"binary\").toString(\"base64\");\n      };\n\n      global.atob = function (data) {\n        return Buffer.from(data, \"base64\").toString(\"binary\");\n      };\n    }\n  })(USE, './base64');\n  ;\n  USE(function (module) {\n    USE('./base64'); // This is Array extended to have .toString(['utf8'|'hex'|'base64'])\n\n    function SeaArray() {}\n\n    Object.assign(SeaArray, {\n      from: Array.from\n    });\n    SeaArray.prototype = Object.create(Array.prototype);\n\n    SeaArray.prototype.toString = function (enc, start, end) {\n      enc = enc || 'utf8';\n      start = start || 0;\n      const length = this.length;\n\n      if (enc === 'hex') {\n        const buf = new Uint8Array(this);\n        return [...Array((end && end + 1 || length) - start).keys()].map(i => buf[i + start].toString(16).padStart(2, '0')).join('');\n      }\n\n      if (enc === 'utf8') {\n        return Array.from({\n          length: (end || length) - start\n        }, (_, i) => String.fromCharCode(this[i + start])).join('');\n      }\n\n      if (enc === 'base64') {\n        return btoa(this);\n      }\n    };\n\n    module.exports = SeaArray;\n  })(USE, './array');\n  ;\n  USE(function (module) {\n    USE('./base64'); // This is Buffer implementation used in SEA. Functionality is mostly\n    // compatible with NodeJS 'safe-buffer' and is used for encoding conversions\n    // between binary and 'hex' | 'utf8' | 'base64'\n    // See documentation and validation for safe implementation in:\n    // https://github.com/feross/safe-buffer#update\n\n    var SeaArray = USE('./array');\n\n    function SafeBuffer() {\n      console.warn('new SafeBuffer() is depreciated, please use SafeBuffer.from()');\n      return SafeBuffer.from(...arguments);\n    }\n\n    SafeBuffer.prototype = Object.create(Array.prototype);\n    Object.assign(SafeBuffer, {\n      // (data, enc) where typeof data === 'string' then enc === 'utf8'|'hex'|'base64'\n      from() {\n        if (!Object.keys(arguments).length || arguments[0] == null) {\n          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n        }\n\n        const input = arguments[0];\n        let buf;\n\n        if (typeof input === 'string') {\n          const enc = arguments[1] || 'utf8';\n\n          if (enc === 'hex') {\n            const bytes = input.match(/([\\da-fA-F]{2})/g).map(byte => parseInt(byte, 16));\n\n            if (!bytes || !bytes.length) {\n              throw new TypeError('Invalid first argument for type \\'hex\\'.');\n            }\n\n            buf = SeaArray.from(bytes);\n          } else if (enc === 'utf8' || 'binary' === enc) {\n            // EDIT BY MARK: I think this is safe, tested it against a couple \"binary\" strings. This lets SafeBuffer match NodeJS Buffer behavior more where it safely btoas regular strings.\n            const length = input.length;\n            const words = new Uint16Array(length);\n            Array.from({\n              length: length\n            }, (_, i) => words[i] = input.charCodeAt(i));\n            buf = SeaArray.from(words);\n          } else if (enc === 'base64') {\n            const dec = atob(input);\n            const length = dec.length;\n            const bytes = new Uint8Array(length);\n            Array.from({\n              length: length\n            }, (_, i) => bytes[i] = dec.charCodeAt(i));\n            buf = SeaArray.from(bytes);\n          } else if (enc === 'binary') {\n            // deprecated by above comment\n            buf = SeaArray.from(input); // some btoas were mishandled.\n          } else {\n            console.info('SafeBuffer.from unknown encoding: ' + enc);\n          }\n\n          return buf;\n        }\n\n        const byteLength = input.byteLength; // what is going on here? FOR MARTTI\n\n        const length = input.byteLength ? input.byteLength : input.length;\n\n        if (length) {\n          let buf;\n\n          if (input instanceof ArrayBuffer) {\n            buf = new Uint8Array(input);\n          }\n\n          return SeaArray.from(buf || input);\n        }\n      },\n\n      // This is 'safe-buffer.alloc' sans encoding support\n      alloc(length) {\n        let fill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        return SeaArray.from(new Uint8Array(Array.from({\n          length: length\n        }, () => fill)));\n      },\n\n      // This is normal UNSAFE 'buffer.alloc' or 'new Buffer(length)' - don't use!\n      allocUnsafe(length) {\n        return SeaArray.from(new Uint8Array(Array.from({\n          length: length\n        })));\n      },\n\n      // This puts together array of array like members\n      concat(arr) {\n        // octet array\n        if (!Array.isArray(arr)) {\n          throw new TypeError('First argument must be Array containing ArrayBuffer or Uint8Array instances.');\n        }\n\n        return SeaArray.from(arr.reduce((ret, item) => ret.concat(Array.from(item)), []));\n      }\n\n    });\n    SafeBuffer.prototype.from = SafeBuffer.from;\n    SafeBuffer.prototype.toString = SeaArray.prototype.toString;\n    module.exports = SafeBuffer;\n  })(USE, './buffer');\n  ;\n  USE(function (module) {\n    const SEA = USE('./root');\n    const api = {\n      Buffer: USE('./buffer')\n    };\n    var o = {},\n        u; // ideally we can move away from JSON entirely? unlikely due to compatibility issues... oh well.\n\n    JSON.parseAsync = JSON.parseAsync || function (t, cb, r) {\n      var u;\n\n      try {\n        cb(u, JSON.parse(t, r));\n      } catch (e) {\n        cb(e);\n      }\n    };\n\n    JSON.stringifyAsync = JSON.stringifyAsync || function (v, cb, r, s) {\n      var u;\n\n      try {\n        cb(u, JSON.stringify(v, r, s));\n      } catch (e) {\n        cb(e);\n      }\n    };\n\n    api.parse = function (t, r) {\n      return new Promise(function (res, rej) {\n        JSON.parseAsync(t, function (err, raw) {\n          err ? rej(err) : res(raw);\n        }, r);\n      });\n    };\n\n    api.stringify = function (v, r, s) {\n      return new Promise(function (res, rej) {\n        JSON.stringifyAsync(v, function (err, raw) {\n          err ? rej(err) : res(raw);\n        }, r, s);\n      });\n    };\n\n    if (SEA.window) {\n      api.crypto = window.crypto || window.msCrypto;\n      api.subtle = (api.crypto || o).subtle || (api.crypto || o).webkitSubtle;\n      api.TextEncoder = window.TextEncoder;\n      api.TextDecoder = window.TextDecoder;\n\n      api.random = len => api.Buffer.from(api.crypto.getRandomValues(new Uint8Array(api.Buffer.alloc(len))));\n    }\n\n    if (!api.TextDecoder) {\n      const {\n        TextEncoder,\n        TextDecoder\n      } = USE((u + '' == typeof MODULE ? '.' : '') + './lib/text-encoding', 1);\n      api.TextDecoder = TextDecoder;\n      api.TextEncoder = TextEncoder;\n    }\n\n    if (!api.crypto) {\n      try {\n        var crypto = USE('crypto', 1);\n        Object.assign(api, {\n          crypto,\n          random: len => api.Buffer.from(crypto.randomBytes(len))\n        });\n        const {\n          Crypto: WebCrypto\n        } = USE('@peculiar/webcrypto', 1);\n        api.ossl = api.subtle = new WebCrypto({\n          directory: 'ossl'\n        }).subtle; // ECDH\n      } catch (e) {\n        console.log(\"Please `npm install @peculiar/webcrypto` or add it to your package.json !\");\n      }\n    }\n\n    module.exports = api;\n  })(USE, './shim');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var s = {};\n    s.pbkdf2 = {\n      hash: {\n        name: 'SHA-256'\n      },\n      iter: 100000,\n      ks: 64\n    };\n    s.ecdsa = {\n      pair: {\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      },\n      sign: {\n        name: 'ECDSA',\n        hash: {\n          name: 'SHA-256'\n        }\n      }\n    };\n    s.ecdh = {\n      name: 'ECDH',\n      namedCurve: 'P-256'\n    }; // This creates Web Cryptography API compliant JWK for sign/verify purposes\n\n    s.jwk = function (pub, d) {\n      // d === priv\n      pub = pub.split('.');\n      var x = pub[0],\n          y = pub[1];\n      var jwk = {\n        kty: \"EC\",\n        crv: \"P-256\",\n        x: x,\n        y: y,\n        ext: true\n      };\n      jwk.key_ops = d ? ['sign'] : ['verify'];\n\n      if (d) {\n        jwk.d = d;\n      }\n\n      return jwk;\n    };\n\n    s.keyToJwk = function (keyBytes) {\n      const keyB64 = keyBytes.toString('base64');\n      const k = keyB64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n      return {\n        kty: 'oct',\n        k: k,\n        ext: false,\n        alg: 'A256GCM'\n      };\n    };\n\n    s.recall = {\n      validity: 12 * 60 * 60,\n      // internally in seconds : 12 hours\n      hook: function (props) {\n        return props;\n      } // { iat, exp, alias, remember } // or return new Promise((resolve, reject) => resolve(props)\n\n    };\n\n    s.check = function (t) {\n      return typeof t == 'string' && 'SEA{' === t.slice(0, 4);\n    };\n\n    s.parse = async function p(t) {\n      try {\n        var yes = typeof t == 'string';\n\n        if (yes && 'SEA{' === t.slice(0, 4)) {\n          t = t.slice(3);\n        }\n\n        return yes ? await shim.parse(t) : t;\n      } catch (e) {}\n\n      return t;\n    };\n\n    SEA.opt = s;\n    module.exports = s;\n  })(USE, './settings');\n  ;\n  USE(function (module) {\n    var shim = USE('./shim');\n\n    module.exports = async function (d, o) {\n      var t = typeof d == 'string' ? d : await shim.stringify(d);\n      var hash = await shim.subtle.digest({\n        name: o || 'SHA-256'\n      }, new shim.TextEncoder().encode(t));\n      return shim.Buffer.from(hash);\n    };\n  })(USE, './sha256');\n  ;\n  USE(function (module) {\n    // This internal func returns SHA-1 hashed data for KeyID generation\n    const __shim = USE('./shim');\n\n    const subtle = __shim.subtle;\n    const ossl = __shim.ossl ? __shim.ossl : subtle;\n\n    const sha1hash = b => ossl.digest({\n      name: 'SHA-1'\n    }, new ArrayBuffer(b));\n\n    module.exports = sha1hash;\n  })(USE, './sha1');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.work = SEA.work || (async (data, pair, cb, opt) => {\n      try {\n        // used to be named `proof`\n        var salt = (pair || {}).epub || pair; // epub not recommended, salt should be random!\n\n        opt = opt || {};\n\n        if (salt instanceof Function) {\n          cb = salt;\n          salt = u;\n        }\n\n        data = typeof data == 'string' ? data : await shim.stringify(data);\n\n        if ('sha' === (opt.name || '').toLowerCase().slice(0, 3)) {\n          var rsha = shim.Buffer.from(await sha(data, opt.name), 'binary').toString(opt.encode || 'base64');\n\n          if (cb) {\n            try {\n              cb(rsha);\n            } catch (e) {\n              console.log(e);\n            }\n          }\n\n          return rsha;\n        }\n\n        salt = salt || shim.random(9);\n        var key = await (shim.ossl || shim.subtle).importKey('raw', new shim.TextEncoder().encode(data), {\n          name: opt.name || 'PBKDF2'\n        }, false, ['deriveBits']);\n        var work = await (shim.ossl || shim.subtle).deriveBits({\n          name: opt.name || 'PBKDF2',\n          iterations: opt.iterations || S.pbkdf2.iter,\n          salt: new shim.TextEncoder().encode(opt.salt || salt),\n          hash: opt.hash || S.pbkdf2.hash\n        }, key, opt.length || S.pbkdf2.ks * 8);\n        data = shim.random(data.length); // Erase data in case of passphrase\n\n        var r = shim.Buffer.from(work, 'binary').toString(opt.encode || 'base64');\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.work;\n  })(USE, './work');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n\n    SEA.name = SEA.name || (async (cb, opt) => {\n      try {\n        if (cb) {\n          try {\n            cb();\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    }); //SEA.pair = async (data, proof, cb) => { try {\n\n\n    SEA.pair = SEA.pair || (async (cb, opt) => {\n      try {\n        var ecdhSubtle = shim.ossl || shim.subtle; // First: ECDSA keys for signing/verifying...\n\n        var sa = await shim.subtle.generateKey({\n          name: 'ECDSA',\n          namedCurve: 'P-256'\n        }, true, ['sign', 'verify']).then(async keys => {\n          // privateKey scope doesn't leak out from here!\n          //const { d: priv } = await shim.subtle.exportKey('jwk', keys.privateKey)\n          var key = {};\n          key.priv = (await shim.subtle.exportKey('jwk', keys.privateKey)).d;\n          var pub = await shim.subtle.exportKey('jwk', keys.publicKey); //const pub = Buff.from([ x, y ].join(':')).toString('base64') // old\n\n          key.pub = pub.x + '.' + pub.y; // new\n          // x and y are already base64\n          // pub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\n          // but split on a non-base64 letter.\n\n          return key;\n        }); // To include PGPv4 kind of keyId:\n        // const pubId = await SEA.keyid(keys.pub)\n        // Next: ECDH keys for encryption/decryption...\n\n        try {\n          var dh = await ecdhSubtle.generateKey({\n            name: 'ECDH',\n            namedCurve: 'P-256'\n          }, true, ['deriveKey']).then(async keys => {\n            // privateKey scope doesn't leak out from here!\n            var key = {};\n            key.epriv = (await ecdhSubtle.exportKey('jwk', keys.privateKey)).d;\n            var pub = await ecdhSubtle.exportKey('jwk', keys.publicKey); //const epub = Buff.from([ ex, ey ].join(':')).toString('base64') // old\n\n            key.epub = pub.x + '.' + pub.y; // new\n            // ex and ey are already base64\n            // epub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\n            // but split on a non-base64 letter.\n\n            return key;\n          });\n        } catch (e) {\n          if (SEA.window) {\n            throw e;\n          }\n\n          if (e == 'Error: ECDH is not a supported algorithm') {\n            console.log('Ignoring ECDH...');\n          } else {\n            throw e;\n          }\n        }\n\n        dh = dh || {};\n        var r = {\n          pub: sa.pub,\n          priv: sa.priv,\n\n          /* pubId, */\n          epub: dh.epub,\n          epriv: dh.epriv\n        };\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.pair;\n  })(USE, './pair');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.sign = SEA.sign || (async (data, pair, cb, opt) => {\n      try {\n        opt = opt || {};\n\n        if (!(pair || opt).priv) {\n          if (!SEA.I) {\n            throw 'No signing key.';\n          }\n\n          pair = await SEA.I(null, {\n            what: data,\n            how: 'sign',\n            why: opt.why\n          });\n        }\n\n        if (u === data) {\n          throw '`undefined` not allowed.';\n        }\n\n        var json = await S.parse(data);\n        var check = opt.check = opt.check || json;\n\n        if (SEA.verify && (SEA.opt.check(check) || check && check.s && check.m) && u !== (await SEA.verify(check, pair))) {\n          // don't sign if we already signed it.\n          var r = await S.parse(check);\n\n          if (!opt.raw) {\n            r = 'SEA' + (await shim.stringify(r));\n          }\n\n          if (cb) {\n            try {\n              cb(r);\n            } catch (e) {\n              console.log(e);\n            }\n          }\n\n          return r;\n        }\n\n        var pub = pair.pub;\n        var priv = pair.priv;\n        var jwk = S.jwk(pub, priv);\n        var hash = await sha(json);\n        var sig = await (shim.ossl || shim.subtle).importKey('jwk', jwk, {\n          name: 'ECDSA',\n          namedCurve: 'P-256'\n        }, false, ['sign']).then(key => (shim.ossl || shim.subtle).sign({\n          name: 'ECDSA',\n          hash: {\n            name: 'SHA-256'\n          }\n        }, key, new Uint8Array(hash))); // privateKey scope doesn't leak out from here!\n\n        var r = {\n          m: json,\n          s: shim.Buffer.from(sig, 'binary').toString(opt.encode || 'base64')\n        };\n\n        if (!opt.raw) {\n          r = 'SEA' + (await shim.stringify(r));\n        }\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.sign;\n  })(USE, './sign');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.verify = SEA.verify || (async (data, pair, cb, opt) => {\n      try {\n        var json = await S.parse(data);\n\n        if (false === pair) {\n          // don't verify!\n          var raw = await S.parse(json.m);\n\n          if (cb) {\n            try {\n              cb(raw);\n            } catch (e) {\n              console.log(e);\n            }\n          }\n\n          return raw;\n        }\n\n        opt = opt || {}; // SEA.I // verify is free! Requires no user permission.\n\n        var pub = pair.pub || pair;\n        var key = SEA.opt.slow_leak ? await SEA.opt.slow_leak(pub) : await (shim.ossl || shim.subtle).importKey('jwk', S.jwk(pub), {\n          name: 'ECDSA',\n          namedCurve: 'P-256'\n        }, false, ['verify']);\n        var hash = await sha(json.m);\n        var buf, sig, check, tmp;\n\n        try {\n          buf = shim.Buffer.from(json.s, opt.encode || 'base64'); // NEW DEFAULT!\n\n          sig = new Uint8Array(buf);\n          check = await (shim.ossl || shim.subtle).verify({\n            name: 'ECDSA',\n            hash: {\n              name: 'SHA-256'\n            }\n          }, key, sig, new Uint8Array(hash));\n\n          if (!check) {\n            throw \"Signature did not match.\";\n          }\n        } catch (e) {\n          if (SEA.opt.fallback) {\n            return await SEA.opt.fall_verify(data, pair, cb, opt);\n          }\n        }\n\n        var r = check ? await S.parse(json.m) : u;\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e); // mismatched owner FOR MARTTI\n\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.verify; // legacy & ossl leak mitigation:\n\n    var knownKeys = {};\n\n    var keyForPair = SEA.opt.slow_leak = pair => {\n      if (knownKeys[pair]) return knownKeys[pair];\n      var jwk = S.jwk(pair);\n      knownKeys[pair] = (shim.ossl || shim.subtle).importKey(\"jwk\", jwk, {\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      }, false, [\"verify\"]);\n      return knownKeys[pair];\n    };\n\n    var O = SEA.opt;\n\n    SEA.opt.fall_verify = async function (data, pair, cb, opt, f) {\n      if (f === SEA.opt.fallback) {\n        throw \"Signature did not match\";\n      }\n\n      f = f || 1;\n      var tmp = data || '';\n      data = SEA.opt.unpack(data) || data;\n      var json = await S.parse(data),\n          pub = pair.pub || pair,\n          key = await SEA.opt.slow_leak(pub);\n      var hash = f <= SEA.opt.fallback ? shim.Buffer.from(await shim.subtle.digest({\n        name: 'SHA-256'\n      }, new shim.TextEncoder().encode(await S.parse(json.m)))) : await sha(json.m); // this line is old bad buggy code but necessary for old compatibility.\n\n      var buf;\n      var sig;\n      var check;\n\n      try {\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64'); // NEW DEFAULT!\n\n        sig = new Uint8Array(buf);\n        check = await (shim.ossl || shim.subtle).verify({\n          name: 'ECDSA',\n          hash: {\n            name: 'SHA-256'\n          }\n        }, key, sig, new Uint8Array(hash));\n\n        if (!check) {\n          throw \"Signature did not match.\";\n        }\n      } catch (e) {\n        try {\n          buf = shim.Buffer.from(json.s, 'utf8'); // AUTO BACKWARD OLD UTF8 DATA!\n\n          sig = new Uint8Array(buf);\n          check = await (shim.ossl || shim.subtle).verify({\n            name: 'ECDSA',\n            hash: {\n              name: 'SHA-256'\n            }\n          }, key, sig, new Uint8Array(hash));\n        } catch (e) {\n          if (!check) {\n            throw \"Signature did not match.\";\n          }\n        }\n      }\n\n      var r = check ? await S.parse(json.m) : u;\n      O.fall_soul = tmp['#'];\n      O.fall_key = tmp['.'];\n      O.fall_val = data;\n      O.fall_state = tmp['>'];\n\n      if (cb) {\n        try {\n          cb(r);\n        } catch (e) {\n          console.log(e);\n        }\n      }\n\n      return r;\n    };\n\n    SEA.opt.fallback = 2;\n  })(USE, './verify');\n  ;\n  USE(function (module) {\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha256hash = USE('./sha256');\n\n    const importGen = async (key, salt, opt) => {\n      //const combo = shim.Buffer.concat([shim.Buffer.from(key, 'utf8'), salt || shim.random(8)]).toString('utf8') // old\n      opt = opt || {};\n      const combo = key + (salt || shim.random(8)).toString('utf8'); // new\n\n      const hash = shim.Buffer.from(await sha256hash(combo), 'binary');\n      const jwkKey = S.keyToJwk(hash);\n      return await shim.subtle.importKey('jwk', jwkKey, {\n        name: 'AES-GCM'\n      }, false, ['encrypt', 'decrypt']);\n    };\n\n    module.exports = importGen;\n  })(USE, './aeskey');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var aeskey = USE('./aeskey');\n    var u;\n\n    SEA.encrypt = SEA.encrypt || (async (data, pair, cb, opt) => {\n      try {\n        opt = opt || {};\n        var key = (pair || opt).epriv || pair;\n\n        if (u === data) {\n          throw '`undefined` not allowed.';\n        }\n\n        if (!key) {\n          if (!SEA.I) {\n            throw 'No encryption key.';\n          }\n\n          pair = await SEA.I(null, {\n            what: data,\n            how: 'encrypt',\n            why: opt.why\n          });\n          key = pair.epriv || pair;\n        }\n\n        var msg = typeof data == 'string' ? data : await shim.stringify(data);\n        var rand = {\n          s: shim.random(9),\n          iv: shim.random(15)\n        }; // consider making this 9 and 15 or 18 or 12 to reduce == padding.\n\n        var ct = await aeskey(key, rand.s, opt).then(aes =>\n        /*shim.ossl ||*/\n        shim.subtle.encrypt({\n          // Keeping the AES key scope as private as possible...\n          name: opt.name || 'AES-GCM',\n          iv: new Uint8Array(rand.iv)\n        }, aes, new shim.TextEncoder().encode(msg)));\n        var r = {\n          ct: shim.Buffer.from(ct, 'binary').toString(opt.encode || 'base64'),\n          iv: rand.iv.toString(opt.encode || 'base64'),\n          s: rand.s.toString(opt.encode || 'base64')\n        };\n\n        if (!opt.raw) {\n          r = 'SEA' + (await shim.stringify(r));\n        }\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.encrypt;\n  })(USE, './encrypt');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var aeskey = USE('./aeskey');\n\n    SEA.decrypt = SEA.decrypt || (async (data, pair, cb, opt) => {\n      try {\n        opt = opt || {};\n        var key = (pair || opt).epriv || pair;\n\n        if (!key) {\n          if (!SEA.I) {\n            throw 'No decryption key.';\n          }\n\n          pair = await SEA.I(null, {\n            what: data,\n            how: 'decrypt',\n            why: opt.why\n          });\n          key = pair.epriv || pair;\n        }\n\n        var json = await S.parse(data);\n        var buf, bufiv, bufct;\n\n        try {\n          buf = shim.Buffer.from(json.s, opt.encode || 'base64');\n          bufiv = shim.Buffer.from(json.iv, opt.encode || 'base64');\n          bufct = shim.Buffer.from(json.ct, opt.encode || 'base64');\n          var ct = await aeskey(key, buf, opt).then(aes =>\n          /*shim.ossl ||*/\n          shim.subtle.decrypt({\n            // Keeping aesKey scope as private as possible...\n            name: opt.name || 'AES-GCM',\n            iv: new Uint8Array(bufiv),\n            tagLength: 128\n          }, aes, new Uint8Array(bufct)));\n        } catch (e) {\n          if ('utf8' === opt.encode) {\n            throw \"Could not decrypt\";\n          }\n\n          if (SEA.opt.fallback) {\n            opt.encode = 'utf8';\n            return await SEA.decrypt(data, pair, cb, opt);\n          }\n        }\n\n        var r = await S.parse(new shim.TextDecoder('utf8').decode(ct));\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.decrypt;\n  })(USE, './decrypt');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings'); // Derive shared secret from other's pub and my epub/epriv \n\n    SEA.secret = SEA.secret || (async (key, pair, cb, opt) => {\n      try {\n        opt = opt || {};\n\n        if (!pair || !pair.epriv || !pair.epub) {\n          if (!SEA.I) {\n            throw 'No secret mix.';\n          }\n\n          pair = await SEA.I(null, {\n            what: key,\n            how: 'secret',\n            why: opt.why\n          });\n        }\n\n        var pub = key.epub || key;\n        var epub = pair.epub;\n        var epriv = pair.epriv;\n        var ecdhSubtle = shim.ossl || shim.subtle;\n        var pubKeyData = keysToEcdhJwk(pub);\n        var props = Object.assign({\n          public: await ecdhSubtle.importKey(...pubKeyData, true, [])\n        }, {\n          name: 'ECDH',\n          namedCurve: 'P-256'\n        }); // Thanks to @sirpy !\n\n        var privKeyData = keysToEcdhJwk(epub, epriv);\n        var derived = await ecdhSubtle.importKey(...privKeyData, false, ['deriveBits']).then(async privKey => {\n          // privateKey scope doesn't leak out from here!\n          var derivedBits = await ecdhSubtle.deriveBits(props, privKey, 256);\n          var rawBits = new Uint8Array(derivedBits);\n          var derivedKey = await ecdhSubtle.importKey('raw', rawBits, {\n            name: 'AES-GCM',\n            length: 256\n          }, true, ['encrypt', 'decrypt']);\n          return ecdhSubtle.exportKey('jwk', derivedKey).then(_ref => {\n            let {\n              k\n            } = _ref;\n            return k;\n          });\n        });\n        var r = derived;\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    }); // can this be replaced with settings.jwk?\n\n\n    var keysToEcdhJwk = (pub, d) => {\n      // d === priv\n      //var [ x, y ] = shim.Buffer.from(pub, 'base64').toString('utf8').split(':') // old\n      var [x, y] = pub.split('.'); // new\n\n      var jwk = d ? {\n        d: d\n      } : {};\n      return [// Use with spread returned value...\n      'jwk', Object.assign(jwk, {\n        x: x,\n        y: y,\n        kty: 'EC',\n        crv: 'P-256',\n        ext: true\n      }), // ??? refactor\n      {\n        name: 'ECDH',\n        namedCurve: 'P-256'\n      }];\n    };\n\n    module.exports = SEA.secret;\n  })(USE, './secret');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root'); // This is to certify that a group of \"certificants\" can \"put\" anything at a group of matched \"paths\" to the certificate authority's graph\n\n    SEA.certify = SEA.certify || async function (certificants) {\n      let policy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let authority = arguments.length > 2 ? arguments[2] : undefined;\n      let cb = arguments.length > 3 ? arguments[3] : undefined;\n      let opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n      try {\n        /*\r\n        The Certify Protocol was made out of love by a Vietnamese code enthusiast. Vietnamese people around the world deserve respect!\r\n        IMPORTANT: A Certificate is like a Signature. No one knows who (authority) created/signed a cert until you put it into their graph.\r\n        \"certificants\": '*' or a String (Bob.pub) || an Object that contains \"pub\" as a key || an array of [object || string]. These people will have the rights.\r\n        \"policy\": A string ('inbox'), or a RAD/LEX object {'*': 'inbox'}, or an Array of RAD/LEX objects or strings. RAD/LEX object can contain key \"?\" with indexOf(\"*\") > -1 to force key equals certificant pub. This rule is used to check against soul+'/'+key using Gun.text.match or String.match.\r\n        \"authority\": Key pair or priv of the certificate authority.\r\n        \"cb\": A callback function after all things are done.\r\n        \"opt\": If opt.expiry (a timestamp) is set, SEA won't sync data after opt.expiry. If opt.block is set, SEA will look for block before syncing.\r\n        */\n        console.log('SEA.certify() is an early experimental community supported method that may change API behavior without warning in any future version.');\n\n        certificants = (() => {\n          var data = [];\n\n          if (certificants) {\n            if ((typeof certificants === 'string' || Array.isArray(certificants)) && certificants.indexOf('*') > -1) return '*';\n            if (typeof certificants === 'string') return certificants;\n\n            if (Array.isArray(certificants)) {\n              if (certificants.length === 1 && certificants[0]) return typeof certificants[0] === 'object' && certificants[0].pub ? certificants[0].pub : typeof certificants[0] === 'string' ? certificants[0] : null;\n              certificants.map(certificant => {\n                if (typeof certificant === 'string') data.push(certificant);else if (typeof certificant === 'object' && certificant.pub) data.push(certificant.pub);\n              });\n            }\n\n            if (typeof certificants === 'object' && certificants.pub) return certificants.pub;\n            return data.length > 0 ? data : null;\n          }\n\n          return;\n        })();\n\n        if (!certificants) return console.log(\"No certificant found.\");\n        const expiry = opt.expiry && (typeof opt.expiry === 'number' || typeof opt.expiry === 'string') ? parseFloat(opt.expiry) : null;\n        const readPolicy = (policy || {}).read ? policy.read : null;\n        const writePolicy = (policy || {}).write ? policy.write : typeof policy === 'string' || Array.isArray(policy) || policy[\"+\"] || policy[\"#\"] || policy[\".\"] || policy[\"=\"] || policy[\"*\"] || policy[\">\"] || policy[\"<\"] ? policy : null; // The \"blacklist\" feature is now renamed to \"block\". Why ? BECAUSE BLACK LIVES MATTER!\n        // We can now use 3 keys: block, blacklist, ban\n\n        const block = (opt || {}).block || (opt || {}).blacklist || (opt || {}).ban || {};\n        const readBlock = block.read && (typeof block.read === 'string' || (block.read || {})['#']) ? block.read : null;\n        const writeBlock = typeof block === 'string' ? block : block.write && (typeof block.write === 'string' || block.write['#']) ? block.write : null;\n        if (!readPolicy && !writePolicy) return console.log(\"No policy found.\"); // reserved keys: c, e, r, w, rb, wb\n\n        const data = JSON.stringify({\n          c: certificants,\n          ...(expiry ? {\n            e: expiry\n          } : {}),\n          // inject expiry if possible\n          ...(readPolicy ? {\n            r: readPolicy\n          } : {}),\n          // \"r\" stands for read, which means read permission.\n          ...(writePolicy ? {\n            w: writePolicy\n          } : {}),\n          // \"w\" stands for write, which means write permission.\n          ...(readBlock ? {\n            rb: readBlock\n          } : {}),\n          // inject READ block if possible\n          ...(writeBlock ? {\n            wb: writeBlock\n          } : {}) // inject WRITE block if possible\n\n        });\n        const certificate = await SEA.sign(data, authority, null, {\n          raw: 1\n        });\n        var r = certificate;\n\n        if (!opt.raw) {\n          r = 'SEA' + JSON.stringify(r);\n        }\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    };\n\n    module.exports = SEA.certify;\n  })(USE, './certify');\n  ;\n  USE(function (module) {\n    var shim = USE('./shim'); // Practical examples about usage found in tests.\n\n    var SEA = USE('./root');\n    SEA.work = USE('./work');\n    SEA.sign = USE('./sign');\n    SEA.verify = USE('./verify');\n    SEA.encrypt = USE('./encrypt');\n    SEA.decrypt = USE('./decrypt');\n    SEA.certify = USE('./certify'); //SEA.opt.aeskey = USE('./aeskey'); // not official! // this causes problems in latest WebCrypto.\n\n    SEA.random = SEA.random || shim.random; // This is Buffer used in SEA and usable from Gun/SEA application also.\n    // For documentation see https://nodejs.org/api/buffer.html\n\n    SEA.Buffer = SEA.Buffer || USE('./buffer'); // These SEA functions support now ony Promises or\n    // async/await (compatible) code, use those like Promises.\n    //\n    // Creates a wrapper library around Web Crypto API\n    // for various AES, ECDSA, PBKDF2 functions we called above.\n    // Calculate public key KeyID aka PGPv4 (result: 8 bytes as hex string)\n\n    SEA.keyid = SEA.keyid || (async pub => {\n      try {\n        // base64('base64(x):base64(y)') => shim.Buffer(xy)\n        const pb = shim.Buffer.concat(pub.replace(/-/g, '+').replace(/_/g, '/').split('.').map(t => shim.Buffer.from(t, 'base64'))); // id is PGPv4 compliant raw key\n\n        const id = shim.Buffer.concat([shim.Buffer.from([0x99, pb.length / 0x100, pb.length % 0x100]), pb]);\n        const sha1 = await sha1hash(id);\n        const hash = shim.Buffer.from(sha1, 'binary');\n        return hash.toString('hex', hash.length - 8); // 16-bit ID as hex\n      } catch (e) {\n        console.log(e);\n        throw e;\n      }\n    }); // all done!\n    // Obviously it is missing MANY necessary features. This is only an alpha release.\n    // Please experiment with it, audit what I've done so far, and complain about what needs to be added.\n    // SEA should be a full suite that is easy and seamless to use.\n    // Again, scroll naer the top, where I provide an EXAMPLE of how to create a user and sign in.\n    // Once logged in, the rest of the code you just read handled automatically signing/validating data.\n    // But all other behavior needs to be equally easy, like opinionated ways of\n    // Adding friends (trusted public keys), sending private messages, etc.\n    // Cheers! Tell me what you think.\n\n\n    ((SEA.window || {}).GUN || {}).SEA = SEA;\n    module.exports = SEA; // -------------- END SEA MODULES --------------------\n    // -- BEGIN SEA+GUN MODULES: BUNDLED BY DEFAULT UNTIL OTHERS USE SEA ON OWN -------\n  })(USE, './sea');\n  ;\n  USE(function (module) {\n    var SEA = USE('./sea'),\n        Gun,\n        u;\n\n    if (SEA.window) {\n      Gun = SEA.window.GUN || {\n        chain: {}\n      };\n    } else {\n      Gun = USE((u + '' == typeof MODULE ? '.' : '') + './gun', 1);\n    }\n\n    SEA.GUN = Gun;\n\n    function User(root) {\n      this._ = {\n        $: this\n      };\n    }\n\n    User.prototype = function () {\n      function F() {}\n\n      ;\n      F.prototype = Gun.chain;\n      return new F();\n    }(); // Object.create polyfill\n\n\n    User.prototype.constructor = User; // let's extend the gun chain with a `user` function.\n    // only one user can be logged in at a time, per gun instance.\n\n    Gun.chain.user = function (pub) {\n      var gun = this,\n          root = gun.back(-1),\n          user;\n\n      if (pub) {\n        pub = SEA.opt.pub((pub._ || '')['#']) || pub;\n        return root.get('~' + pub);\n      }\n\n      if (user = root.back('user')) {\n        return user;\n      }\n\n      var root = root._,\n          at = root,\n          uuid = at.opt.uuid || lex;\n      (at = (user = at.user = gun.chain(new User()))._).opt = {};\n\n      at.opt.uuid = function (cb) {\n        var id = uuid(),\n            pub = root.user;\n\n        if (!pub || !(pub = pub.is) || !(pub = pub.pub)) {\n          return id;\n        }\n\n        id = '~' + pub + '/' + id;\n\n        if (cb && cb.call) {\n          cb(null, id);\n        }\n\n        return id;\n      };\n\n      return user;\n    };\n\n    function lex() {\n      return Gun.state().toString(36).replace('.', '');\n    }\n\n    Gun.User = User;\n    User.GUN = Gun;\n    User.SEA = Gun.SEA = SEA;\n    module.exports = User;\n  })(USE, './user');\n  ;\n  USE(function (module) {\n    var u,\n        Gun = '' + u != typeof window ? window.Gun || {\n      chain: {}\n    } : USE(('' + u === typeof MODULE ? '.' : '') + './gun', 1);\n\n    Gun.chain.then = function (cb, opt) {\n      var gun = this,\n          p = new Promise(function (res, rej) {\n        gun.once(res, opt);\n      });\n      return cb ? p.then(cb) : p;\n    };\n  })(USE, './then');\n  ;\n  USE(function (module) {\n    var User = USE('./user'),\n        SEA = User.SEA,\n        Gun = User.GUN,\n        noop = function () {}; // Well first we have to actually create a user. That is what this function does.\n\n\n    User.prototype.create = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\n      var alias = pair && (pair.pub || pair.epub) ? pair.pub : typeof args[0] === 'string' ? args[0] : null;\n      var pass = pair && (pair.pub || pair.epub) ? pair : alias && typeof args[1] === 'string' ? args[1] : null;\n      var cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\n\n      var opt = args && args.length > 1 && typeof args[args.length - 1] === 'object' ? args[args.length - 1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\n\n      var gun = this,\n          cat = gun._,\n          root = gun.back(-1);\n      cb = cb || noop;\n      opt = opt || {};\n\n      if (false !== opt.check) {\n        var err;\n\n        if (!alias) {\n          err = \"No user.\";\n        }\n\n        if ((pass || '').length < 8) {\n          err = \"Password too short!\";\n        }\n\n        if (err) {\n          cb({\n            err: Gun.log(err)\n          });\n          return gun;\n        }\n      }\n\n      if (cat.ing) {\n        (cb || noop)({\n          err: Gun.log(\"User is already being created or authenticated!\"),\n          wait: true\n        });\n        return gun;\n      }\n\n      cat.ing = true;\n      var act = {},\n          u;\n\n      act.a = function (pubs) {\n        act.pubs = pubs;\n\n        if (pubs && !opt.already) {\n          // If we can enforce that a user name is already taken, it might be nice to try, but this is not guaranteed.\n          var ack = {\n            err: Gun.log('User already created!')\n          };\n          cat.ing = false;\n          (cb || noop)(ack);\n          gun.leave();\n          return;\n        }\n\n        act.salt = String.random(64); // pseudo-randomly create a salt, then use PBKDF2 function to extend the password with it.\n\n        SEA.work(pass, act.salt, act.b); // this will take some short amount of time to produce a proof, which slows brute force attacks.\n      };\n\n      act.b = function (proof) {\n        act.proof = proof;\n        pair ? act.c(pair) : SEA.pair(act.c); // generate a brand new key pair or use the existing.\n      };\n\n      act.c = function (pair) {\n        var tmp;\n        act.pair = pair || {};\n\n        if (tmp = cat.root.user) {\n          tmp._.sea = pair;\n          tmp.is = {\n            pub: pair.pub,\n            epub: pair.epub,\n            alias: alias\n          };\n        } // the user's public key doesn't need to be signed. But everything else needs to be signed with it! // we have now automated it! clean up these extra steps now!\n\n\n        act.data = {\n          pub: pair.pub\n        };\n        act.d();\n      };\n\n      act.d = function () {\n        act.data.alias = alias;\n        act.e();\n      };\n\n      act.e = function () {\n        act.data.epub = act.pair.epub;\n        SEA.encrypt({\n          priv: act.pair.priv,\n          epriv: act.pair.epriv\n        }, act.proof, act.f, {\n          raw: 1\n        }); // to keep the private key safe, we AES encrypt it with the proof of work!\n      };\n\n      act.f = function (auth) {\n        act.data.auth = JSON.stringify({\n          ek: auth,\n          s: act.salt\n        });\n        act.g(act.data.auth);\n      };\n\n      act.g = function (auth) {\n        var tmp;\n        act.data.auth = act.data.auth || auth;\n        root.get(tmp = '~' + act.pair.pub).put(act.data).on(act.h); // awesome, now we can actually save the user with their public key as their ID.\n\n        var link = {};\n        link[tmp] = {\n          '#': tmp\n        };\n        root.get('~@' + alias).put(link).get(tmp).on(act.i); // next up, we want to associate the alias with the public key. So we add it to the alias list.\n      };\n\n      act.h = function (data, key, msg, eve) {\n        eve.off();\n        act.h.ok = 1;\n        act.i();\n      };\n\n      act.i = function (data, key, msg, eve) {\n        if (eve) {\n          act.i.ok = 1;\n          eve.off();\n        }\n\n        if (!act.h.ok || !act.i.ok) {\n          return;\n        }\n\n        cat.ing = false;\n        cb({\n          ok: 0,\n          pub: act.pair.pub\n        }); // callback that the user has been created. (Note: ok = 0 because we didn't wait for disk to ack)\n\n        if (noop === cb) {\n          pair ? gun.auth(pair) : gun.auth(alias, pass);\n        } // if no callback is passed, auto-login after signing up.\n\n      };\n\n      root.get('~@' + alias).once(act.a);\n      return gun;\n    };\n\n    User.prototype.leave = function (opt, cb) {\n      var gun = this,\n          user = gun.back(-1)._.user;\n\n      if (user) {\n        delete user.is;\n        delete user._.is;\n        delete user._.sea;\n      }\n\n      if (SEA.window) {\n        try {\n          var sS = {};\n          sS = window.sessionStorage;\n          delete sS.recall;\n          delete sS.pair;\n        } catch (e) {}\n\n        ;\n      }\n\n      return gun;\n    };\n  })(USE, './create');\n  ;\n  USE(function (module) {\n    var User = USE('./user'),\n        SEA = User.SEA,\n        Gun = User.GUN,\n        noop = function () {}; // now that we have created a user, we want to authenticate them!\n\n\n    User.prototype.auth = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      // TODO: this PR with arguments need to be cleaned up / refactored.\n      var pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\n      var alias = !pair && typeof args[0] === 'string' ? args[0] : null;\n      var pass = alias && typeof args[1] === 'string' ? args[1] : null;\n      var cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\n\n      var opt = args && args.length > 1 && typeof args[args.length - 1] === 'object' ? args[args.length - 1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\n\n      var gun = this,\n          cat = gun._,\n          root = gun.back(-1);\n\n      if (cat.ing) {\n        (cb || noop)({\n          err: Gun.log(\"User is already being created or authenticated!\"),\n          wait: true\n        });\n        return gun;\n      }\n\n      cat.ing = true;\n      var act = {},\n          u;\n\n      act.a = function (data) {\n        if (!data) {\n          return act.b();\n        }\n\n        if (!data.pub) {\n          var tmp = [];\n          Object.keys(data).forEach(function (k) {\n            if ('_' == k) {\n              return;\n            }\n\n            tmp.push(data[k]);\n          });\n          return act.b(tmp);\n        }\n\n        if (act.name) {\n          return act.f(data);\n        }\n\n        act.c((act.data = data).auth);\n      };\n\n      act.b = function (list) {\n        var get = (act.list = (act.list || []).concat(list || [])).shift();\n\n        if (u === get) {\n          if (act.name) {\n            return act.err('Your user account is not published for dApps to access, please consider syncing it online, or allowing local access by adding your device as a peer.');\n          }\n\n          return act.err('Wrong user or password.');\n        }\n\n        root.get(get).once(act.a);\n      };\n\n      act.c = function (auth) {\n        if (u === auth) {\n          return act.b();\n        }\n\n        if ('string' == typeof auth) {\n          return act.c(obj_ify(auth));\n        } // in case of legacy\n\n\n        SEA.work(pass, (act.auth = auth).s, act.d, act.enc); // the proof of work is evidence that we've spent some time/effort trying to log in, this slows brute force.\n      };\n\n      act.d = function (proof) {\n        SEA.decrypt(act.auth.ek, proof, act.e, act.enc);\n      };\n\n      act.e = function (half) {\n        if (u === half) {\n          if (!act.enc) {\n            // try old format\n            act.enc = {\n              encode: 'utf8'\n            };\n            return act.c(act.auth);\n          }\n\n          act.enc = null; // end backwards\n\n          return act.b();\n        }\n\n        act.half = half;\n        act.f(act.data);\n      };\n\n      act.f = function (pair) {\n        var half = act.half || {},\n            data = act.data || {};\n        act.g(act.lol = {\n          pub: pair.pub || data.pub,\n          epub: pair.epub || data.epub,\n          priv: pair.priv || half.priv,\n          epriv: pair.epriv || half.epriv\n        });\n      };\n\n      act.g = function (pair) {\n        if (!pair || !pair.pub || !pair.epub) {\n          return act.b();\n        }\n\n        act.pair = pair;\n        var user = root._.user,\n            at = user._;\n        var tmp = at.tag;\n        var upt = at.opt;\n        at = user._ = root.get('~' + pair.pub)._;\n        at.opt = upt; // add our credentials in-memory only to our root user instance\n\n        user.is = {\n          pub: pair.pub,\n          epub: pair.epub,\n          alias: alias || pair.pub\n        };\n        at.sea = act.pair;\n        cat.ing = false;\n\n        try {\n          if (pass && u == (obj_ify(cat.root.graph['~' + pair.pub].auth) || '')[':']) {\n            opt.shuffle = opt.change = pass;\n          }\n        } catch (e) {} // migrate UTF8 & Shuffle!\n\n\n        opt.change ? act.z() : (cb || noop)(at);\n\n        if (SEA.window && (gun.back('user')._.opt || opt).remember) {\n          // TODO: this needs to be modular.\n          try {\n            var sS = {};\n            sS = window.sessionStorage; // TODO: FIX BUG putting on `.is`!\n\n            sS.recall = true;\n            sS.pair = JSON.stringify(pair); // auth using pair is more reliable than alias/pass\n          } catch (e) {}\n        }\n\n        try {\n          if (root._.tag.auth) {\n            // auth handle might not be registered yet\n            root._.on('auth', at); // TODO: Deprecate this, emit on user instead! Update docs when you do.\n\n          } else {\n            setTimeout(function () {\n              root._.on('auth', at);\n            }, 1);\n          } // if not, hackily add a timeout.\n          //at.on('auth', at) // Arrgh, this doesn't work without event \"merge\" code, but \"merge\" code causes stack overflow and crashes after logging in & trying to write data.\n\n        } catch (e) {\n          Gun.log(\"Your 'auth' callback crashed with:\", e);\n        }\n      };\n\n      act.z = function () {\n        // password update so encrypt private key using new pwd + salt\n        act.salt = String.random(64); // pseudo-random\n\n        SEA.work(opt.change, act.salt, act.y);\n      };\n\n      act.y = function (proof) {\n        SEA.encrypt({\n          priv: act.pair.priv,\n          epriv: act.pair.epriv\n        }, proof, act.x, {\n          raw: 1\n        });\n      };\n\n      act.x = function (auth) {\n        act.w(JSON.stringify({\n          ek: auth,\n          s: act.salt\n        }));\n      };\n\n      act.w = function (auth) {\n        if (opt.shuffle) {\n          // delete in future!\n          console.log('migrate core account from UTF8 & shuffle');\n          var tmp = {};\n          Object.keys(act.data).forEach(function (k) {\n            tmp[k] = act.data[k];\n          });\n          delete tmp._;\n          tmp.auth = auth;\n          root.get('~' + act.pair.pub).put(tmp);\n        } // end delete\n\n\n        root.get('~' + act.pair.pub).get('auth').put(auth, cb || noop);\n      };\n\n      act.err = function (e) {\n        var ack = {\n          err: Gun.log(e || 'User cannot be found!')\n        };\n        cat.ing = false;\n        (cb || noop)(ack);\n      };\n\n      act.plugin = function (name) {\n        if (!(act.name = name)) {\n          return act.err();\n        }\n\n        var tmp = [name];\n\n        if ('~' !== name[0]) {\n          tmp[1] = '~' + name;\n          tmp[2] = '~@' + name;\n        }\n\n        act.b(tmp);\n      };\n\n      if (pair) {\n        act.g(pair);\n      } else if (alias) {\n        root.get('~@' + alias).once(act.a);\n      } else if (!alias && !pass) {\n        SEA.name(act.plugin);\n      }\n\n      return gun;\n    };\n\n    function obj_ify(o) {\n      if ('string' != typeof o) {\n        return o;\n      }\n\n      try {\n        o = JSON.parse(o);\n      } catch (e) {\n        o = {};\n      }\n\n      ;\n      return o;\n    }\n  })(USE, './auth');\n  ;\n  USE(function (module) {\n    var User = USE('./user'),\n        SEA = User.SEA,\n        Gun = User.GUN;\n\n    User.prototype.recall = function (opt, cb) {\n      var gun = this,\n          root = gun.back(-1),\n          tmp;\n      opt = opt || {};\n\n      if (opt && opt.sessionStorage) {\n        if (SEA.window) {\n          try {\n            var sS = {};\n            sS = window.sessionStorage; // TODO: FIX BUG putting on `.is`!\n\n            if (sS) {\n              root._.opt.remember = true;\n              (gun.back('user')._.opt || opt).remember = true;\n              if (sS.recall || sS.pair) root.user().auth(JSON.parse(sS.pair), cb); // pair is more reliable than alias/pass\n            }\n          } catch (e) {}\n        }\n\n        return gun;\n      }\n      /*\r\n        TODO: copy mhelander's expiry code back in.\r\n        Although, we should check with community,\r\n        should expiry be core or a plugin?\r\n      */\n\n\n      return gun;\n    };\n  })(USE, './recall');\n  ;\n  USE(function (module) {\n    var User = USE('./user'),\n        SEA = User.SEA,\n        Gun = User.GUN,\n        noop = function () {};\n\n    User.prototype.pair = function () {\n      var user = this,\n          proxy; // undeprecated, hiding with proxies.\n\n      try {\n        proxy = new Proxy({\n          DANGER: '\\u2620'\n        }, {\n          get: function (t, p, r) {\n            if (!user.is || !(user._ || '').sea) {\n              return;\n            }\n\n            return user._.sea[p];\n          }\n        });\n      } catch (e) {}\n\n      return proxy;\n    }; // If authenticated user wants to delete his/her account, let's support it!\n\n\n    User.prototype.delete = async function (alias, pass, cb) {\n      console.log(\"user.delete() IS DEPRECATED AND WILL BE MOVED TO A MODULE!!!\");\n      var gun = this,\n          root = gun.back(-1),\n          user = gun.back('user');\n\n      try {\n        user.auth(alias, pass, function (ack) {\n          var pub = (user.is || {}).pub; // Delete user data\n\n          user.map().once(function () {\n            this.put(null);\n          }); // Wipe user data from memory\n\n          user.leave();\n          (cb || noop)({\n            ok: 0\n          });\n        });\n      } catch (e) {\n        Gun.log('User.delete failed! Error:', e);\n      }\n\n      return gun;\n    };\n\n    User.prototype.alive = async function () {\n      console.log(\"user.alive() IS DEPRECATED!!!\");\n      const gunRoot = this.back(-1);\n\n      try {\n        // All is good. Should we do something more with actual recalled data?\n        await authRecall(gunRoot);\n        return gunRoot._.user._;\n      } catch (e) {\n        const err = 'No session!';\n        Gun.log(err);\n        throw {\n          err\n        };\n      }\n    };\n\n    User.prototype.trust = async function (user) {\n      console.log(\"`.trust` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\"); // TODO: BUG!!! SEA `node` read listener needs to be async, which means core needs to be async too.\n      //gun.get('alice').get('age').trust(bob);\n\n      if (Gun.is(user)) {\n        user.get('pub').get((ctx, ev) => {\n          console.log(ctx, ev);\n        });\n      }\n\n      user.get('trust').get(path).put(theirPubkey); // do a lookup on this gun chain directly (that gets bob's copy of the data)\n      // do a lookup on the metadata trust table for this path (that gets all the pubkeys allowed to write on this path)\n      // do a lookup on each of those pubKeys ON the path (to get the collab data \"layers\")\n      // THEN you perform Jachen's mix operation\n      // and return the result of that to...\n    };\n\n    User.prototype.grant = function (to, cb) {\n      console.log(\"`.grant` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      var gun = this,\n          user = gun.back(-1).user(),\n          pair = user._.sea,\n          path = '';\n      gun.back(function (at) {\n        if (at.is) {\n          return;\n        }\n\n        path += at.get || '';\n      });\n\n      (async function () {\n        var enc,\n            sec = await user.get('grant').get(pair.pub).get(path).then();\n        sec = await SEA.decrypt(sec, pair);\n\n        if (!sec) {\n          sec = SEA.random(16).toString();\n          enc = await SEA.encrypt(sec, pair);\n          user.get('grant').get(pair.pub).get(path).put(enc);\n        }\n\n        var pub = to.get('pub').then();\n        var epub = to.get('epub').then();\n        pub = await pub;\n        epub = await epub;\n        var dh = await SEA.secret(epub, pair);\n        enc = await SEA.encrypt(sec, dh);\n        user.get('grant').get(pub).get(path).put(enc, cb);\n      })();\n\n      return gun;\n    };\n\n    User.prototype.secret = function (data, cb) {\n      console.log(\"`.secret` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      var gun = this,\n          user = gun.back(-1).user(),\n          pair = user.pair(),\n          path = '';\n      gun.back(function (at) {\n        if (at.is) {\n          return;\n        }\n\n        path += at.get || '';\n      });\n\n      (async function () {\n        var enc,\n            sec = await user.get('trust').get(pair.pub).get(path).then();\n        sec = await SEA.decrypt(sec, pair);\n\n        if (!sec) {\n          sec = SEA.random(16).toString();\n          enc = await SEA.encrypt(sec, pair);\n          user.get('trust').get(pair.pub).get(path).put(enc);\n        }\n\n        enc = await SEA.encrypt(data, sec);\n        gun.put(enc, cb);\n      })();\n\n      return gun;\n    };\n    /**\r\n     * returns the decrypted value, encrypted by secret\r\n     * @returns {Promise<any>}\r\n     // Mark needs to review 1st before officially supported\r\n    User.prototype.decrypt = function(cb) {\r\n      let gun = this,\r\n        path = ''\r\n      gun.back(function(at) {\r\n        if (at.is) {\r\n          return\r\n        }\r\n        path += at.get || ''\r\n      })\r\n      return gun\r\n        .then(async data => {\r\n          if (data == null) {\r\n            return\r\n          }\r\n          const user = gun.back(-1).user()\r\n          const pair = user.pair()\r\n          let sec = await user\r\n            .get('trust')\r\n            .get(pair.pub)\r\n            .get(path)\r\n          sec = await SEA.decrypt(sec, pair)\r\n          if (!sec) {\r\n            return data\r\n          }\r\n          let decrypted = await SEA.decrypt(data, sec)\r\n          return decrypted\r\n        })\r\n        .then(res => {\r\n          cb && cb(res)\r\n          return res\r\n        })\r\n    }\r\n    */\n\n\n    module.exports = User;\n  })(USE, './share');\n  ;\n  USE(function (module) {\n    var SEA = USE('./sea'),\n        S = USE('./settings'),\n        noop = function () {},\n        u;\n\n    var Gun = '' + u != typeof window ? window.Gun || {\n      on: noop\n    } : USE(('' + u === typeof MODULE ? '.' : '') + './gun', 1); // After we have a GUN extension to make user registration/login easy, we then need to handle everything else.\n    // We do this with a GUN adapter, we first listen to when a gun instance is created (and when its options change)\n\n    Gun.on('opt', function (at) {\n      if (!at.sea) {\n        // only add SEA once per instance, on the \"at\" context.\n        at.sea = {\n          own: {}\n        };\n        at.on('put', check, at); // SEA now runs its firewall on HAM diffs, not all i/o.\n      }\n\n      this.to.next(at); // make sure to call the \"next\" middleware adapter.\n    }); // Alright, this next adapter gets run at the per node level in the graph database.\n    // correction: 2020 it gets run on each key/value pair in a node upon a HAM diff.\n    // This will let us verify that every property on a node has a value signed by a public key we trust.\n    // If the signature does not match, the data is just `undefined` so it doesn't get passed on.\n    // If it does match, then we transform the in-memory \"view\" of the data into its plain value (without the signature).\n    // Now NOTE! Some data is \"system\" data, not user data. Example: List of public keys, aliases, etc.\n    // This data is self-enforced (the value can only match its ID), but that is handled in the `security` function.\n    // From the self-enforced data, we can see all the edges in the graph that belong to a public key.\n    // Example: ~ASDF is the ID of a node with ASDF as its public key, signed alias and salt, and\n    // its encrypted private key, but it might also have other signed values on it like `profile = <ID>` edge.\n    // Using that directed edge's ID, we can then track (in memory) which IDs belong to which keys.\n    // Here is a problem: Multiple public keys can \"claim\" any node's ID, so this is dangerous!\n    // This means we should ONLY trust our \"friends\" (our key ring) public keys, not any ones.\n    // I have not yet added that to SEA yet in this alpha release. That is coming soon, but beware in the meanwhile!\n\n    function check(msg) {\n      // REVISE / IMPROVE, NO NEED TO PASS MSG/EVE EACH SUB?\n      var eve = this,\n          at = eve.as,\n          put = msg.put,\n          soul = put['#'],\n          key = put['.'],\n          val = put[':'],\n          state = put['>'],\n          id = msg['#'],\n          tmp;\n\n      if (!soul || !key) {\n        return;\n      }\n\n      if ((msg._ || '').faith && (at.opt || '').faith && 'function' == typeof msg._) {\n        SEA.opt.pack(put, function (raw) {\n          SEA.verify(raw, false, function (data) {\n            // this is synchronous if false\n            put['='] = SEA.opt.unpack(data);\n            eve.to.next(msg);\n          });\n        });\n        return;\n      }\n\n      var no = function (why) {\n        at.on('in', {\n          '@': id,\n          err: msg.err = why\n        });\n      }; // exploit internal relay stun for now, maybe violates spec, but testing for now. // Note: this may be only the sharded message, not original batch.\n      //var no = function(why){ msg.ack(why) };\n\n\n      (msg._ || '').DBG && ((msg._ || '').DBG.c = +new Date());\n\n      if (0 <= soul.indexOf('<?')) {\n        // special case for \"do not sync data X old\" forget\n        // 'a~pub.key/b<?9'\n        tmp = parseFloat(soul.split('<?')[1] || '');\n\n        if (tmp && state < Gun.state() - tmp * 1000) {\n          // sec to ms\n          (tmp = msg._) && tmp.stun && tmp.stun--; // THIS IS BAD CODE! It assumes GUN internals do something that will probably change in future, but hacking in now.\n\n          return; // omit!\n        }\n      }\n\n      if ('~@' === soul) {\n        // special case for shared system data, the list of aliases.\n        check.alias(eve, msg, val, key, soul, at, no);\n        return;\n      }\n\n      if ('~@' === soul.slice(0, 2)) {\n        // special case for shared system data, the list of public keys for an alias.\n        check.pubs(eve, msg, val, key, soul, at, no);\n        return;\n      } //if('~' === soul.slice(0,1) && 2 === (tmp = soul.slice(1)).split('.').length){ // special case, account data for a public key.\n\n\n      if (tmp = SEA.opt.pub(soul)) {\n        // special case, account data for a public key.\n        check.pub(eve, msg, val, key, soul, at, no, at.user || '', tmp);\n        return;\n      }\n\n      if (0 <= soul.indexOf('#')) {\n        // special case for content addressing immutable hashed data.\n        check.hash(eve, msg, val, key, soul, at, no);\n        return;\n      }\n\n      check.any(eve, msg, val, key, soul, at, no, at.user || '');\n      return;\n      eve.to.next(msg); // not handled\n    }\n\n    check.hash = function (eve, msg, val, key, soul, at, no) {\n      SEA.work(val, null, function (data) {\n        if (data && data === key.split('#').slice(-1)[0]) {\n          return eve.to.next(msg);\n        }\n\n        no(\"Data hash not same as hash!\");\n      }, {\n        name: 'SHA-256'\n      });\n    };\n\n    check.alias = function (eve, msg, val, key, soul, at, no) {\n      // Example: {_:#~@, ~@alice: {#~@alice}}\n      if (!val) {\n        return no(\"Data must exist!\");\n      } // data MUST exist\n\n\n      if ('~@' + key === link_is(val)) {\n        return eve.to.next(msg);\n      } // in fact, it must be EXACTLY equal to itself\n\n\n      no(\"Alias not same!\"); // if it isn't, reject.\n    };\n\n    check.pubs = function (eve, msg, val, key, soul, at, no) {\n      // Example: {_:#~@alice, ~asdf: {#~asdf}}\n      if (!val) {\n        return no(\"Alias must exist!\");\n      } // data MUST exist\n\n\n      if (key === link_is(val)) {\n        return eve.to.next(msg);\n      } // and the ID must be EXACTLY equal to its property\n\n\n      no(\"Alias not same!\"); // that way nobody can tamper with the list of public keys.\n    };\n\n    check.pub = async function (eve, msg, val, key, soul, at, no, user, pub) {\n      var tmp; // Example: {_:#~asdf, hello:'world'~fdsa}}\n\n      const raw = (await S.parse(val)) || {};\n\n      const verify = (certificate, certificant, cb) => {\n        if (certificate.m && certificate.s && certificant && pub) // now verify certificate\n          return SEA.verify(certificate, pub, data => {\n            // check if \"pub\" (of the graph owner) really issued this cert\n            if (u !== data && u !== data.e && msg.put['>'] && msg.put['>'] > parseFloat(data.e)) return no(\"Certificate expired.\"); // certificate expired\n            // \"data.c\" = a list of certificants/certified users\n            // \"data.w\" = lex WRITE permission, in the future, there will be \"data.r\" which means lex READ permission\n\n            if (u !== data && data.c && data.w && (data.c === certificant || data.c.indexOf('*' || certificant) > -1)) {\n              // ok, now \"certificant\" is in the \"certificants\" list, but is \"path\" allowed? Check path\n              let path = soul.indexOf('/') > -1 ? soul.replace(soul.substring(0, soul.indexOf('/') + 1), '') : '';\n              String.match = String.match || Gun.text.match;\n              const w = Array.isArray(data.w) ? data.w : typeof data.w === 'object' || typeof data.w === 'string' ? [data.w] : [];\n\n              for (const lex of w) {\n                if (String.match(path, lex['#']) && String.match(key, lex['.']) || !lex['.'] && String.match(path, lex['#']) || !lex['#'] && String.match(key, lex['.']) || String.match(path ? path + '/' + key : key, lex['#'] || lex)) {\n                  // is Certificant forced to present in Path\n                  if (lex['+'] && lex['+'].indexOf('*') > -1 && path && path.indexOf(certificant) == -1 && key.indexOf(certificant) == -1) return no(`Path \"${path}\" or key \"${key}\" must contain string \"${certificant}\".`); // path is allowed, but is there any WRITE block? Check it out\n\n                  if (data.wb && (typeof data.wb === 'string' || (data.wb || {})['#'])) {\n                    // \"data.wb\" = path to the WRITE block\n                    var root = eve.as.root.$.back(-1);\n                    if (typeof data.wb === 'string' && '~' !== data.wb.slice(0, 1)) root = root.get('~' + pub);\n                    return root.get(data.wb).get(certificant).once(value => {\n                      if (value && (value === 1 || value === true)) return no(`Certificant ${certificant} blocked.`);\n                      return cb(data);\n                    });\n                  }\n\n                  return cb(data);\n                }\n              }\n\n              return no(\"Certificate verification fail.\");\n            }\n          });\n        return;\n      };\n\n      if ('pub' === key && '~' + pub === soul) {\n        if (val === pub) return eve.to.next(msg); // the account MUST match `pub` property that equals the ID of the public key.\n\n        return no(\"Account not same!\");\n      }\n\n      if ((tmp = user.is) && tmp.pub && !raw['*'] && !raw['+'] && (pub === tmp.pub || pub !== tmp.pub && ((msg._.msg || {}).opt || {}).cert)) {\n        SEA.opt.pack(msg.put, packed => {\n          SEA.sign(packed, user._.sea, async function (data) {\n            if (u === data) return no(SEA.err || 'Signature fail.');\n            msg.put[':'] = {\n              ':': tmp = SEA.opt.unpack(data.m),\n              '~': data.s\n            };\n            msg.put['='] = tmp; // if writing to own graph, just allow it\n\n            if (pub === user.is.pub) {\n              if (tmp = link_is(val)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1;\n              JSON.stringifyAsync(msg.put[':'], function (err, s) {\n                if (err) {\n                  return no(err || \"Stringify error.\");\n                }\n\n                msg.put[':'] = s;\n                return eve.to.next(msg);\n              });\n              return;\n            } // if writing to other's graph, check if cert exists then try to inject cert into put, also inject self pub so that everyone can verify the put\n\n\n            if (pub !== user.is.pub && ((msg._.msg || {}).opt || {}).cert) {\n              const cert = await S.parse(msg._.msg.opt.cert); // even if cert exists, we must verify it\n\n              if (cert && cert.m && cert.s) verify(cert, user.is.pub, _ => {\n                msg.put[':']['+'] = cert; // '+' is a certificate\n\n                msg.put[':']['*'] = user.is.pub; // '*' is pub of the user who puts\n\n                JSON.stringifyAsync(msg.put[':'], function (err, s) {\n                  if (err) {\n                    return no(err || \"Stringify error.\");\n                  }\n\n                  msg.put[':'] = s;\n                  return eve.to.next(msg);\n                });\n                return;\n              });\n            }\n          }, {\n            raw: 1\n          });\n        });\n        return;\n      }\n\n      SEA.opt.pack(msg.put, packed => {\n        SEA.verify(packed, raw['*'] || pub, function (data) {\n          var tmp;\n          data = SEA.opt.unpack(data);\n          if (u === data) return no(\"Unverified data.\"); // make sure the signature matches the account it claims to be on. // reject any updates that are signed with a mismatched account.\n\n          if ((tmp = link_is(data)) && pub === SEA.opt.pub(tmp)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1; // check if cert ('+') and putter's pub ('*') exist\n\n          if (raw['+'] && raw['+']['m'] && raw['+']['s'] && raw['*']) // now verify certificate\n            verify(raw['+'], raw['*'], _ => {\n              msg.put['='] = data;\n              return eve.to.next(msg);\n            });else {\n            msg.put['='] = data;\n            return eve.to.next(msg);\n          }\n        });\n      });\n      return;\n    };\n\n    check.any = function (eve, msg, val, key, soul, at, no, user) {\n      var tmp, pub;\n\n      if (at.opt.secure) {\n        return no(\"Soul missing public key at '\" + key + \"'.\");\n      } // TODO: Ask community if should auto-sign non user-graph data.\n\n\n      at.on('secure', function (msg) {\n        this.off();\n\n        if (!at.opt.secure) {\n          return eve.to.next(msg);\n        }\n\n        no(\"Data cannot be changed.\");\n      }).on.on('secure', msg);\n      return;\n    };\n\n    var valid = Gun.valid,\n        link_is = function (d, l) {\n      return 'string' == typeof (l = valid(d)) && l;\n    },\n        state_ify = (Gun.state || '').ify;\n\n    var pubcut = /[^\\w_-]/; // anything not alphanumeric or _ -\n\n    SEA.opt.pub = function (s) {\n      if (!s) {\n        return;\n      }\n\n      s = s.split('~');\n\n      if (!s || !(s = s[1])) {\n        return;\n      }\n\n      s = s.split(pubcut).slice(0, 2);\n\n      if (!s || 2 != s.length) {\n        return;\n      }\n\n      if ('@' === (s[0] || '')[0]) {\n        return;\n      }\n\n      s = s.slice(0, 2).join('.');\n      return s;\n    };\n\n    SEA.opt.stringy = function (t) {// TODO: encrypt etc. need to check string primitive. Make as breaking change.\n    };\n\n    SEA.opt.pack = function (d, cb, k, n, s) {\n      var tmp, f; // pack for verifying\n\n      if (SEA.opt.check(d)) {\n        return cb(d);\n      }\n\n      if (d && d['#'] && d['.'] && d['>']) {\n        tmp = d[':'];\n        f = 1;\n      }\n\n      JSON.parseAsync(f ? tmp : d, function (err, meta) {\n        var sig = u !== (meta || '')[':'] && (meta || '')['~']; // or just ~ check?\n\n        if (!sig) {\n          cb(d);\n          return;\n        }\n\n        cb({\n          m: {\n            '#': s || d['#'],\n            '.': k || d['.'],\n            ':': (meta || '')[':'],\n            '>': d['>'] || Gun.state.is(n, k)\n          },\n          s: sig\n        });\n      });\n    };\n\n    var O = SEA.opt;\n\n    SEA.opt.unpack = function (d, k, n) {\n      var tmp;\n\n      if (u === d) {\n        return;\n      }\n\n      if (d && u !== (tmp = d[':'])) {\n        return tmp;\n      }\n\n      k = k || O.fall_key;\n\n      if (!n && O.fall_val) {\n        n = {};\n        n[k] = O.fall_val;\n      }\n\n      if (!k || !n) {\n        return;\n      }\n\n      if (d === n[k]) {\n        return d;\n      }\n\n      if (!SEA.opt.check(n[k])) {\n        return d;\n      }\n\n      var soul = n && n._ && n._['#'] || O.fall_soul,\n          s = Gun.state.is(n, k) || O.fall_state;\n\n      if (d && 4 === d.length && soul === d[0] && k === d[1] && fl(s) === fl(d[3])) {\n        return d[2];\n      }\n\n      if (s < SEA.opt.shuffle_attack) {\n        return d;\n      }\n    };\n\n    SEA.opt.shuffle_attack = 1546329600000; // Jan 1, 2019\n\n    var fl = Math.floor; // TODO: Still need to fix inconsistent state issue.\n    // TODO: Potential bug? If pub/priv key starts with `-`? IDK how possible.\n  })(USE, './index');\n})();","map":{"version":3,"sources":["C:/Users/Y9FMLC706/Documents/Bright/node_modules/gun/sea.js"],"names":["USE","arg","req","require","slice","R","mod","path","exports","p","split","toString","replace","module","MODULE","window","tmp","u","SEA","e","location","protocol","indexOf","host","test","hostname","console","warn","btoa","Buffer","global","log","data","from","atob","SeaArray","Object","assign","Array","prototype","create","enc","start","end","length","buf","Uint8Array","keys","map","i","padStart","join","_","String","fromCharCode","SafeBuffer","arguments","TypeError","input","bytes","match","byte","parseInt","words","Uint16Array","charCodeAt","dec","info","byteLength","ArrayBuffer","alloc","fill","allocUnsafe","concat","arr","isArray","reduce","ret","item","api","o","JSON","parseAsync","t","cb","r","parse","stringifyAsync","v","s","stringify","Promise","res","rej","err","raw","crypto","msCrypto","subtle","webkitSubtle","TextEncoder","TextDecoder","random","len","getRandomValues","randomBytes","Crypto","WebCrypto","ossl","directory","shim","pbkdf2","hash","name","iter","ks","ecdsa","pair","namedCurve","sign","ecdh","jwk","pub","d","x","y","kty","crv","ext","key_ops","keyToJwk","keyBytes","keyB64","k","alg","recall","validity","hook","props","check","yes","opt","digest","encode","__shim","sha1hash","b","S","sha","work","salt","epub","Function","toLowerCase","rsha","key","importKey","deriveBits","iterations","throw","ecdhSubtle","sa","generateKey","then","priv","exportKey","privateKey","publicKey","dh","epriv","I","what","how","why","json","verify","m","sig","slow_leak","fallback","fall_verify","knownKeys","keyForPair","O","f","unpack","fall_soul","fall_key","fall_val","fall_state","sha256hash","importGen","combo","jwkKey","aeskey","encrypt","msg","rand","iv","ct","aes","decrypt","bufiv","bufct","tagLength","decode","secret","pubKeyData","keysToEcdhJwk","public","privKeyData","derived","privKey","derivedBits","rawBits","derivedKey","certify","certificants","policy","authority","certificant","push","expiry","parseFloat","readPolicy","read","writePolicy","write","block","blacklist","ban","readBlock","writeBlock","c","w","rb","wb","certificate","keyid","pb","id","sha1","GUN","Gun","chain","User","root","$","F","constructor","user","gun","back","get","at","uuid","lex","is","call","state","once","noop","args","alias","pass","filter","cat","ing","wait","act","a","pubs","already","ack","leave","proof","sea","auth","ek","g","put","on","h","link","eve","off","ok","sS","sessionStorage","forEach","list","shift","obj_ify","half","lol","tag","upt","graph","shuffle","change","z","remember","setTimeout","plugin","proxy","Proxy","DANGER","delete","alive","gunRoot","authRecall","trust","ctx","ev","theirPubkey","grant","to","sec","own","next","as","soul","val","faith","pack","no","DBG","Date","stun","any","link_is","substring","text","value","cert","packed","secure","valid","l","state_ify","ify","pubcut","stringy","n","meta","fl","shuffle_attack","Math","floor"],"mappings":"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","sourcesContent":[";(function(){\r\n\r\n  /* UNBUILD */\r\n  function USE(arg, req){\r\n    return req? require(arg) : arg.slice? USE[R(arg)] : function(mod, path){\r\n      arg(mod = {exports: {}});\r\n      USE[R(path)] = mod.exports;\r\n    }\r\n    function R(p){\r\n      return p.split('/').slice(-1).toString().replace('.js','');\r\n    }\r\n  }\r\n  if(typeof module !== \"undefined\"){ var MODULE = module }\r\n  /* UNBUILD */\r\n\r\n  ;USE(function(module){\r\n    // Security, Encryption, and Authorization: SEA.js\r\n    // MANDATORY READING: https://gun.eco/explainers/data/security.html\r\n    // IT IS IMPLEMENTED IN A POLYFILL/SHIM APPROACH.\r\n    // THIS IS AN EARLY ALPHA!\r\n\r\n    if(typeof window !== \"undefined\"){ module.window = window }\r\n\r\n    var tmp = module.window || module, u;\r\n    var SEA = tmp.SEA || {};\r\n\r\n    if(SEA.window = module.window){ SEA.window.SEA = SEA }\r\n\r\n    try{ if(u+'' !== typeof MODULE){ MODULE.exports = SEA } }catch(e){}\r\n    module.exports = SEA;\r\n  })(USE, './root');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./root');\r\n    try{ if(SEA.window){\r\n      if(location.protocol.indexOf('s') < 0\r\n      && location.host.indexOf('localhost') < 0\r\n      && ! /^127\\.\\d+\\.\\d+\\.\\d+$/.test(location.hostname)\r\n      && location.protocol.indexOf('file:') < 0){\r\n        console.warn('HTTPS needed for WebCrypto in SEA, redirecting...');\r\n        location.protocol = 'https:'; // WebCrypto does NOT work without HTTPS!\r\n      }\r\n    } }catch(e){}\r\n  })(USE, './https');\r\n\r\n  ;USE(function(module){\r\n    var u;\r\n    if(u+''== typeof btoa){\r\n      if(u+'' == typeof Buffer){\r\n        try{ global.Buffer = USE(\"buffer\", 1).Buffer }catch(e){ console.log(\"Please `npm install buffer` or add it to your package.json !\") }\r\n      }\r\n      global.btoa = function(data){ return Buffer.from(data, \"binary\").toString(\"base64\") };\r\n      global.atob = function(data){ return Buffer.from(data, \"base64\").toString(\"binary\") };\r\n    }\r\n  })(USE, './base64');\r\n\r\n  ;USE(function(module){\r\n    USE('./base64');\r\n    // This is Array extended to have .toString(['utf8'|'hex'|'base64'])\r\n    function SeaArray() {}\r\n    Object.assign(SeaArray, { from: Array.from })\r\n    SeaArray.prototype = Object.create(Array.prototype)\r\n    SeaArray.prototype.toString = function(enc, start, end) { enc = enc || 'utf8'; start = start || 0;\r\n      const length = this.length\r\n      if (enc === 'hex') {\r\n        const buf = new Uint8Array(this)\r\n        return [ ...Array(((end && (end + 1)) || length) - start).keys()]\r\n        .map((i) => buf[ i + start ].toString(16).padStart(2, '0')).join('')\r\n      }\r\n      if (enc === 'utf8') {\r\n        return Array.from(\r\n          { length: (end || length) - start },\r\n          (_, i) => String.fromCharCode(this[ i + start])\r\n        ).join('')\r\n      }\r\n      if (enc === 'base64') {\r\n        return btoa(this)\r\n      }\r\n    }\r\n    module.exports = SeaArray;\r\n  })(USE, './array');\r\n\r\n  ;USE(function(module){\r\n    USE('./base64');\r\n    // This is Buffer implementation used in SEA. Functionality is mostly\r\n    // compatible with NodeJS 'safe-buffer' and is used for encoding conversions\r\n    // between binary and 'hex' | 'utf8' | 'base64'\r\n    // See documentation and validation for safe implementation in:\r\n    // https://github.com/feross/safe-buffer#update\r\n    var SeaArray = USE('./array');\r\n    function SafeBuffer(...props) {\r\n      console.warn('new SafeBuffer() is depreciated, please use SafeBuffer.from()')\r\n      return SafeBuffer.from(...props)\r\n    }\r\n    SafeBuffer.prototype = Object.create(Array.prototype)\r\n    Object.assign(SafeBuffer, {\r\n      // (data, enc) where typeof data === 'string' then enc === 'utf8'|'hex'|'base64'\r\n      from() {\r\n        if (!Object.keys(arguments).length || arguments[0]==null) {\r\n          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\r\n        }\r\n        const input = arguments[0]\r\n        let buf\r\n        if (typeof input === 'string') {\r\n          const enc = arguments[1] || 'utf8'\r\n          if (enc === 'hex') {\r\n            const bytes = input.match(/([\\da-fA-F]{2})/g)\r\n            .map((byte) => parseInt(byte, 16))\r\n            if (!bytes || !bytes.length) {\r\n              throw new TypeError('Invalid first argument for type \\'hex\\'.')\r\n            }\r\n            buf = SeaArray.from(bytes)\r\n          } else if (enc === 'utf8' || 'binary' === enc) { // EDIT BY MARK: I think this is safe, tested it against a couple \"binary\" strings. This lets SafeBuffer match NodeJS Buffer behavior more where it safely btoas regular strings.\r\n            const length = input.length\r\n            const words = new Uint16Array(length)\r\n            Array.from({ length: length }, (_, i) => words[i] = input.charCodeAt(i))\r\n            buf = SeaArray.from(words)\r\n          } else if (enc === 'base64') {\r\n            const dec = atob(input)\r\n            const length = dec.length\r\n            const bytes = new Uint8Array(length)\r\n            Array.from({ length: length }, (_, i) => bytes[i] = dec.charCodeAt(i))\r\n            buf = SeaArray.from(bytes)\r\n          } else if (enc === 'binary') { // deprecated by above comment\r\n            buf = SeaArray.from(input) // some btoas were mishandled.\r\n          } else {\r\n            console.info('SafeBuffer.from unknown encoding: '+enc)\r\n          }\r\n          return buf\r\n        }\r\n        const byteLength = input.byteLength // what is going on here? FOR MARTTI\r\n        const length = input.byteLength ? input.byteLength : input.length\r\n        if (length) {\r\n          let buf\r\n          if (input instanceof ArrayBuffer) {\r\n            buf = new Uint8Array(input)\r\n          }\r\n          return SeaArray.from(buf || input)\r\n        }\r\n      },\r\n      // This is 'safe-buffer.alloc' sans encoding support\r\n      alloc(length, fill = 0 /*, enc*/ ) {\r\n        return SeaArray.from(new Uint8Array(Array.from({ length: length }, () => fill)))\r\n      },\r\n      // This is normal UNSAFE 'buffer.alloc' or 'new Buffer(length)' - don't use!\r\n      allocUnsafe(length) {\r\n        return SeaArray.from(new Uint8Array(Array.from({ length : length })))\r\n      },\r\n      // This puts together array of array like members\r\n      concat(arr) { // octet array\r\n        if (!Array.isArray(arr)) {\r\n          throw new TypeError('First argument must be Array containing ArrayBuffer or Uint8Array instances.')\r\n        }\r\n        return SeaArray.from(arr.reduce((ret, item) => ret.concat(Array.from(item)), []))\r\n      }\r\n    })\r\n    SafeBuffer.prototype.from = SafeBuffer.from\r\n    SafeBuffer.prototype.toString = SeaArray.prototype.toString\r\n\r\n    module.exports = SafeBuffer;\r\n  })(USE, './buffer');\r\n\r\n  ;USE(function(module){\r\n    const SEA = USE('./root')\r\n    const api = {Buffer: USE('./buffer')}\r\n    var o = {}, u;\r\n\r\n    // ideally we can move away from JSON entirely? unlikely due to compatibility issues... oh well.\r\n    JSON.parseAsync = JSON.parseAsync || function(t,cb,r){ var u; try{ cb(u, JSON.parse(t,r)) }catch(e){ cb(e) } }\r\n    JSON.stringifyAsync = JSON.stringifyAsync || function(v,cb,r,s){ var u; try{ cb(u, JSON.stringify(v,r,s)) }catch(e){ cb(e) } }\r\n\r\n    api.parse = function(t,r){ return new Promise(function(res, rej){\r\n      JSON.parseAsync(t,function(err, raw){ err? rej(err) : res(raw) },r);\r\n    })}\r\n    api.stringify = function(v,r,s){ return new Promise(function(res, rej){\r\n      JSON.stringifyAsync(v,function(err, raw){ err? rej(err) : res(raw) },r,s);\r\n    })}\r\n\r\n    if(SEA.window){\r\n      api.crypto = window.crypto || window.msCrypto\r\n      api.subtle = (api.crypto||o).subtle || (api.crypto||o).webkitSubtle;\r\n      api.TextEncoder = window.TextEncoder;\r\n      api.TextDecoder = window.TextDecoder;\r\n      api.random = (len) => api.Buffer.from(api.crypto.getRandomValues(new Uint8Array(api.Buffer.alloc(len))));\r\n    }\r\n    if(!api.TextDecoder)\r\n    {\r\n      const { TextEncoder, TextDecoder } = USE((u+'' == typeof MODULE?'.':'')+'./lib/text-encoding', 1);\r\n      api.TextDecoder = TextDecoder;\r\n      api.TextEncoder = TextEncoder;\r\n    }\r\n    if(!api.crypto)\r\n    {\r\n      try\r\n      {\r\n      var crypto = USE('crypto', 1);\r\n      Object.assign(api, {\r\n        crypto,\r\n        random: (len) => api.Buffer.from(crypto.randomBytes(len))\r\n      });      \r\n      const { Crypto: WebCrypto } = USE('@peculiar/webcrypto', 1);\r\n      api.ossl = api.subtle = new WebCrypto({directory: 'ossl'}).subtle // ECDH\r\n    }\r\n    catch(e){\r\n      console.log(\"Please `npm install @peculiar/webcrypto` or add it to your package.json !\");\r\n    }}\r\n\r\n    module.exports = api\r\n  })(USE, './shim');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./root');\r\n    var shim = USE('./shim');\r\n    var s = {};\r\n    s.pbkdf2 = {hash: {name : 'SHA-256'}, iter: 100000, ks: 64};\r\n    s.ecdsa = {\r\n      pair: {name: 'ECDSA', namedCurve: 'P-256'},\r\n      sign: {name: 'ECDSA', hash: {name: 'SHA-256'}}\r\n    };\r\n    s.ecdh = {name: 'ECDH', namedCurve: 'P-256'};\r\n\r\n    // This creates Web Cryptography API compliant JWK for sign/verify purposes\r\n    s.jwk = function(pub, d){  // d === priv\r\n      pub = pub.split('.');\r\n      var x = pub[0], y = pub[1];\r\n      var jwk = {kty: \"EC\", crv: \"P-256\", x: x, y: y, ext: true};\r\n      jwk.key_ops = d ? ['sign'] : ['verify'];\r\n      if(d){ jwk.d = d }\r\n      return jwk;\r\n    };\r\n    \r\n    s.keyToJwk = function(keyBytes) {\r\n      const keyB64 = keyBytes.toString('base64');\r\n      const k = keyB64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\r\n      return { kty: 'oct', k: k, ext: false, alg: 'A256GCM' };\r\n    }\r\n\r\n    s.recall = {\r\n      validity: 12 * 60 * 60, // internally in seconds : 12 hours\r\n      hook: function(props){ return props } // { iat, exp, alias, remember } // or return new Promise((resolve, reject) => resolve(props)\r\n    };\r\n\r\n    s.check = function(t){ return (typeof t == 'string') && ('SEA{' === t.slice(0,4)) }\r\n    s.parse = async function p(t){ try {\r\n      var yes = (typeof t == 'string');\r\n      if(yes && 'SEA{' === t.slice(0,4)){ t = t.slice(3) }\r\n      return yes ? await shim.parse(t) : t;\r\n      } catch (e) {}\r\n      return t;\r\n    }\r\n\r\n    SEA.opt = s;\r\n    module.exports = s\r\n  })(USE, './settings');\r\n\r\n  ;USE(function(module){\r\n    var shim = USE('./shim');\r\n    module.exports = async function(d, o){\r\n      var t = (typeof d == 'string')? d : await shim.stringify(d);\r\n      var hash = await shim.subtle.digest({name: o||'SHA-256'}, new shim.TextEncoder().encode(t));\r\n      return shim.Buffer.from(hash);\r\n    }\r\n  })(USE, './sha256');\r\n\r\n  ;USE(function(module){\r\n    // This internal func returns SHA-1 hashed data for KeyID generation\r\n    const __shim = USE('./shim')\r\n    const subtle = __shim.subtle\r\n    const ossl = __shim.ossl ? __shim.ossl : subtle\r\n    const sha1hash = (b) => ossl.digest({name: 'SHA-1'}, new ArrayBuffer(b))\r\n    module.exports = sha1hash\r\n  })(USE, './sha1');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./root');\r\n    var shim = USE('./shim');\r\n    var S = USE('./settings');\r\n    var sha = USE('./sha256');\r\n    var u;\r\n\r\n    SEA.work = SEA.work || (async (data, pair, cb, opt) => { try { // used to be named `proof`\r\n      var salt = (pair||{}).epub || pair; // epub not recommended, salt should be random!\r\n      opt = opt || {};\r\n      if(salt instanceof Function){\r\n        cb = salt;\r\n        salt = u;\r\n      }\r\n      data = (typeof data == 'string')? data : await shim.stringify(data);\r\n      if('sha' === (opt.name||'').toLowerCase().slice(0,3)){\r\n        var rsha = shim.Buffer.from(await sha(data, opt.name), 'binary').toString(opt.encode || 'base64')\r\n        if(cb){ try{ cb(rsha) }catch(e){console.log(e)} }\r\n        return rsha;\r\n      }\r\n      salt = salt || shim.random(9);\r\n      var key = await (shim.ossl || shim.subtle).importKey('raw', new shim.TextEncoder().encode(data), {name: opt.name || 'PBKDF2'}, false, ['deriveBits']);\r\n      var work = await (shim.ossl || shim.subtle).deriveBits({\r\n        name: opt.name || 'PBKDF2',\r\n        iterations: opt.iterations || S.pbkdf2.iter,\r\n        salt: new shim.TextEncoder().encode(opt.salt || salt),\r\n        hash: opt.hash || S.pbkdf2.hash,\r\n      }, key, opt.length || (S.pbkdf2.ks * 8))\r\n      data = shim.random(data.length)  // Erase data in case of passphrase\r\n      var r = shim.Buffer.from(work, 'binary').toString(opt.encode || 'base64')\r\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\r\n      return r;\r\n    } catch(e) { \r\n      console.log(e);\r\n      SEA.err = e;\r\n      if(SEA.throw){ throw e }\r\n      if(cb){ cb() }\r\n      return;\r\n    }});\r\n\r\n    module.exports = SEA.work;\r\n  })(USE, './work');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./root');\r\n    var shim = USE('./shim');\r\n    var S = USE('./settings');\r\n\r\n    SEA.name = SEA.name || (async (cb, opt) => { try {\r\n      if(cb){ try{ cb() }catch(e){console.log(e)} }\r\n      return;\r\n    } catch(e) {\r\n      console.log(e);\r\n      SEA.err = e;\r\n      if(SEA.throw){ throw e }\r\n      if(cb){ cb() }\r\n      return;\r\n    }});\r\n\r\n    //SEA.pair = async (data, proof, cb) => { try {\r\n    SEA.pair = SEA.pair || (async (cb, opt) => { try {\r\n\r\n      var ecdhSubtle = shim.ossl || shim.subtle;\r\n      // First: ECDSA keys for signing/verifying...\r\n      var sa = await shim.subtle.generateKey({name: 'ECDSA', namedCurve: 'P-256'}, true, [ 'sign', 'verify' ])\r\n      .then(async (keys) => {\r\n        // privateKey scope doesn't leak out from here!\r\n        //const { d: priv } = await shim.subtle.exportKey('jwk', keys.privateKey)\r\n        var key = {};\r\n        key.priv = (await shim.subtle.exportKey('jwk', keys.privateKey)).d;\r\n        var pub = await shim.subtle.exportKey('jwk', keys.publicKey);\r\n        //const pub = Buff.from([ x, y ].join(':')).toString('base64') // old\r\n        key.pub = pub.x+'.'+pub.y; // new\r\n        // x and y are already base64\r\n        // pub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\r\n        // but split on a non-base64 letter.\r\n        return key;\r\n      })\r\n      \r\n      // To include PGPv4 kind of keyId:\r\n      // const pubId = await SEA.keyid(keys.pub)\r\n      // Next: ECDH keys for encryption/decryption...\r\n\r\n      try{\r\n      var dh = await ecdhSubtle.generateKey({name: 'ECDH', namedCurve: 'P-256'}, true, ['deriveKey'])\r\n      .then(async (keys) => {\r\n        // privateKey scope doesn't leak out from here!\r\n        var key = {};\r\n        key.epriv = (await ecdhSubtle.exportKey('jwk', keys.privateKey)).d;\r\n        var pub = await ecdhSubtle.exportKey('jwk', keys.publicKey);\r\n        //const epub = Buff.from([ ex, ey ].join(':')).toString('base64') // old\r\n        key.epub = pub.x+'.'+pub.y; // new\r\n        // ex and ey are already base64\r\n        // epub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\r\n        // but split on a non-base64 letter.\r\n        return key;\r\n      })\r\n      }catch(e){\r\n        if(SEA.window){ throw e }\r\n        if(e == 'Error: ECDH is not a supported algorithm'){ console.log('Ignoring ECDH...') }\r\n        else { throw e }\r\n      } dh = dh || {};\r\n\r\n      var r = { pub: sa.pub, priv: sa.priv, /* pubId, */ epub: dh.epub, epriv: dh.epriv }\r\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\r\n      return r;\r\n    } catch(e) {\r\n      console.log(e);\r\n      SEA.err = e;\r\n      if(SEA.throw){ throw e }\r\n      if(cb){ cb() }\r\n      return;\r\n    }});\r\n\r\n    module.exports = SEA.pair;\r\n  })(USE, './pair');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./root');\r\n    var shim = USE('./shim');\r\n    var S = USE('./settings');\r\n    var sha = USE('./sha256');\r\n    var u;\r\n\r\n    SEA.sign = SEA.sign || (async (data, pair, cb, opt) => { try {\r\n      opt = opt || {};\r\n      if(!(pair||opt).priv){\r\n        if(!SEA.I){ throw 'No signing key.' }\r\n        pair = await SEA.I(null, {what: data, how: 'sign', why: opt.why});\r\n      }\r\n      if(u === data){ throw '`undefined` not allowed.' }\r\n      var json = await S.parse(data);\r\n      var check = opt.check = opt.check || json;\r\n      if(SEA.verify && (SEA.opt.check(check) || (check && check.s && check.m))\r\n      && u !== await SEA.verify(check, pair)){ // don't sign if we already signed it.\r\n        var r = await S.parse(check);\r\n        if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\r\n        if(cb){ try{ cb(r) }catch(e){console.log(e)} }\r\n        return r;\r\n      }\r\n      var pub = pair.pub;\r\n      var priv = pair.priv;\r\n      var jwk = S.jwk(pub, priv);\r\n      var hash = await sha(json);\r\n      var sig = await (shim.ossl || shim.subtle).importKey('jwk', jwk, {name: 'ECDSA', namedCurve: 'P-256'}, false, ['sign'])\r\n      .then((key) => (shim.ossl || shim.subtle).sign({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, new Uint8Array(hash))) // privateKey scope doesn't leak out from here!\r\n      var r = {m: json, s: shim.Buffer.from(sig, 'binary').toString(opt.encode || 'base64')}\r\n      if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\r\n\r\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\r\n      return r;\r\n    } catch(e) {\r\n      console.log(e);\r\n      SEA.err = e;\r\n      if(SEA.throw){ throw e }\r\n      if(cb){ cb() }\r\n      return;\r\n    }});\r\n\r\n    module.exports = SEA.sign;\r\n  })(USE, './sign');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./root');\r\n    var shim = USE('./shim');\r\n    var S = USE('./settings');\r\n    var sha = USE('./sha256');\r\n    var u;\r\n\r\n    SEA.verify = SEA.verify || (async (data, pair, cb, opt) => { try {\r\n      var json = await S.parse(data);\r\n      if(false === pair){ // don't verify!\r\n        var raw = await S.parse(json.m);\r\n        if(cb){ try{ cb(raw) }catch(e){console.log(e)} }\r\n        return raw;\r\n      }\r\n      opt = opt || {};\r\n      // SEA.I // verify is free! Requires no user permission.\r\n      var pub = pair.pub || pair;\r\n      var key = SEA.opt.slow_leak? await SEA.opt.slow_leak(pub) : await (shim.ossl || shim.subtle).importKey('jwk', S.jwk(pub), {name: 'ECDSA', namedCurve: 'P-256'}, false, ['verify']);\r\n      var hash = await sha(json.m);\r\n      var buf, sig, check, tmp; try{\r\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64'); // NEW DEFAULT!\r\n        sig = new Uint8Array(buf);\r\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash));\r\n        if(!check){ throw \"Signature did not match.\" }\r\n      }catch(e){\r\n        if(SEA.opt.fallback){\r\n          return await SEA.opt.fall_verify(data, pair, cb, opt);\r\n        }\r\n      }\r\n      var r = check? await S.parse(json.m) : u;\r\n\r\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\r\n      return r;\r\n    } catch(e) {\r\n      console.log(e); // mismatched owner FOR MARTTI\r\n      SEA.err = e;\r\n      if(SEA.throw){ throw e }\r\n      if(cb){ cb() }\r\n      return;\r\n    }});\r\n\r\n    module.exports = SEA.verify;\r\n    // legacy & ossl leak mitigation:\r\n\r\n    var knownKeys = {};\r\n    var keyForPair = SEA.opt.slow_leak = pair => {\r\n      if (knownKeys[pair]) return knownKeys[pair];\r\n      var jwk = S.jwk(pair);\r\n      knownKeys[pair] = (shim.ossl || shim.subtle).importKey(\"jwk\", jwk, {name: 'ECDSA', namedCurve: 'P-256'}, false, [\"verify\"]);\r\n      return knownKeys[pair];\r\n    };\r\n\r\n    var O = SEA.opt;\r\n    SEA.opt.fall_verify = async function(data, pair, cb, opt, f){\r\n      if(f === SEA.opt.fallback){ throw \"Signature did not match\" } f = f || 1;\r\n      var tmp = data||'';\r\n      data = SEA.opt.unpack(data) || data;\r\n      var json = await S.parse(data), pub = pair.pub || pair, key = await SEA.opt.slow_leak(pub);\r\n      var hash = (f <= SEA.opt.fallback)? shim.Buffer.from(await shim.subtle.digest({name: 'SHA-256'}, new shim.TextEncoder().encode(await S.parse(json.m)))) : await sha(json.m); // this line is old bad buggy code but necessary for old compatibility.\r\n      var buf; var sig; var check; try{\r\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64') // NEW DEFAULT!\r\n        sig = new Uint8Array(buf)\r\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash))\r\n        if(!check){ throw \"Signature did not match.\" }\r\n      }catch(e){ try{\r\n        buf = shim.Buffer.from(json.s, 'utf8') // AUTO BACKWARD OLD UTF8 DATA!\r\n        sig = new Uint8Array(buf)\r\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash))\r\n        }catch(e){\r\n        if(!check){ throw \"Signature did not match.\" }\r\n        }\r\n      }\r\n      var r = check? await S.parse(json.m) : u;\r\n      O.fall_soul = tmp['#']; O.fall_key = tmp['.']; O.fall_val = data; O.fall_state = tmp['>'];\r\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\r\n      return r;\r\n    }\r\n    SEA.opt.fallback = 2;\r\n\r\n  })(USE, './verify');\r\n\r\n  ;USE(function(module){\r\n    var shim = USE('./shim');\r\n    var S = USE('./settings');\r\n    var sha256hash = USE('./sha256');\r\n\r\n    const importGen = async (key, salt, opt) => {\r\n      //const combo = shim.Buffer.concat([shim.Buffer.from(key, 'utf8'), salt || shim.random(8)]).toString('utf8') // old\r\n      opt = opt || {};\r\n      const combo = key + (salt || shim.random(8)).toString('utf8'); // new\r\n      const hash = shim.Buffer.from(await sha256hash(combo), 'binary')\r\n      \r\n      const jwkKey = S.keyToJwk(hash)      \r\n      return await shim.subtle.importKey('jwk', jwkKey, {name:'AES-GCM'}, false, ['encrypt', 'decrypt'])\r\n    }\r\n    module.exports = importGen;\r\n  })(USE, './aeskey');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./root');\r\n    var shim = USE('./shim');\r\n    var S = USE('./settings');\r\n    var aeskey = USE('./aeskey');\r\n    var u;\r\n\r\n    SEA.encrypt = SEA.encrypt || (async (data, pair, cb, opt) => { try {\r\n      opt = opt || {};\r\n      var key = (pair||opt).epriv || pair;\r\n      if(u === data){ throw '`undefined` not allowed.' }\r\n      if(!key){\r\n        if(!SEA.I){ throw 'No encryption key.' }\r\n        pair = await SEA.I(null, {what: data, how: 'encrypt', why: opt.why});\r\n        key = pair.epriv || pair;\r\n      }\r\n      var msg = (typeof data == 'string')? data : await shim.stringify(data);\r\n      var rand = {s: shim.random(9), iv: shim.random(15)}; // consider making this 9 and 15 or 18 or 12 to reduce == padding.\r\n      var ct = await aeskey(key, rand.s, opt).then((aes) => (/*shim.ossl ||*/ shim.subtle).encrypt({ // Keeping the AES key scope as private as possible...\r\n        name: opt.name || 'AES-GCM', iv: new Uint8Array(rand.iv)\r\n      }, aes, new shim.TextEncoder().encode(msg)));\r\n      var r = {\r\n        ct: shim.Buffer.from(ct, 'binary').toString(opt.encode || 'base64'),\r\n        iv: rand.iv.toString(opt.encode || 'base64'),\r\n        s: rand.s.toString(opt.encode || 'base64')\r\n      }\r\n      if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\r\n\r\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\r\n      return r;\r\n    } catch(e) { \r\n      console.log(e);\r\n      SEA.err = e;\r\n      if(SEA.throw){ throw e }\r\n      if(cb){ cb() }\r\n      return;\r\n    }});\r\n\r\n    module.exports = SEA.encrypt;\r\n  })(USE, './encrypt');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./root');\r\n    var shim = USE('./shim');\r\n    var S = USE('./settings');\r\n    var aeskey = USE('./aeskey');\r\n\r\n    SEA.decrypt = SEA.decrypt || (async (data, pair, cb, opt) => { try {\r\n      opt = opt || {};\r\n      var key = (pair||opt).epriv || pair;\r\n      if(!key){\r\n        if(!SEA.I){ throw 'No decryption key.' }\r\n        pair = await SEA.I(null, {what: data, how: 'decrypt', why: opt.why});\r\n        key = pair.epriv || pair;\r\n      }\r\n      var json = await S.parse(data);\r\n      var buf, bufiv, bufct; try{\r\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64');\r\n        bufiv = shim.Buffer.from(json.iv, opt.encode || 'base64');\r\n        bufct = shim.Buffer.from(json.ct, opt.encode || 'base64');\r\n        var ct = await aeskey(key, buf, opt).then((aes) => (/*shim.ossl ||*/ shim.subtle).decrypt({  // Keeping aesKey scope as private as possible...\r\n          name: opt.name || 'AES-GCM', iv: new Uint8Array(bufiv), tagLength: 128\r\n        }, aes, new Uint8Array(bufct)));\r\n      }catch(e){\r\n        if('utf8' === opt.encode){ throw \"Could not decrypt\" }\r\n        if(SEA.opt.fallback){\r\n          opt.encode = 'utf8';\r\n          return await SEA.decrypt(data, pair, cb, opt);\r\n        }\r\n      }\r\n      var r = await S.parse(new shim.TextDecoder('utf8').decode(ct));\r\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\r\n      return r;\r\n    } catch(e) { \r\n      console.log(e);\r\n      SEA.err = e;\r\n      if(SEA.throw){ throw e }\r\n      if(cb){ cb() }\r\n      return;\r\n    }});\r\n\r\n    module.exports = SEA.decrypt;\r\n  })(USE, './decrypt');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./root');\r\n    var shim = USE('./shim');\r\n    var S = USE('./settings');\r\n    // Derive shared secret from other's pub and my epub/epriv \r\n    SEA.secret = SEA.secret || (async (key, pair, cb, opt) => { try {\r\n      opt = opt || {};\r\n      if(!pair || !pair.epriv || !pair.epub){\r\n        if(!SEA.I){ throw 'No secret mix.' }\r\n        pair = await SEA.I(null, {what: key, how: 'secret', why: opt.why});\r\n      }\r\n      var pub = key.epub || key;\r\n      var epub = pair.epub;\r\n      var epriv = pair.epriv;\r\n      var ecdhSubtle = shim.ossl || shim.subtle;\r\n      var pubKeyData = keysToEcdhJwk(pub);\r\n      var props = Object.assign({ public: await ecdhSubtle.importKey(...pubKeyData, true, []) },{name: 'ECDH', namedCurve: 'P-256'}); // Thanks to @sirpy !\r\n      var privKeyData = keysToEcdhJwk(epub, epriv);\r\n      var derived = await ecdhSubtle.importKey(...privKeyData, false, ['deriveBits']).then(async (privKey) => {\r\n        // privateKey scope doesn't leak out from here!\r\n        var derivedBits = await ecdhSubtle.deriveBits(props, privKey, 256);\r\n        var rawBits = new Uint8Array(derivedBits);\r\n        var derivedKey = await ecdhSubtle.importKey('raw', rawBits,{ name: 'AES-GCM', length: 256 }, true, [ 'encrypt', 'decrypt' ]);\r\n        return ecdhSubtle.exportKey('jwk', derivedKey).then(({ k }) => k);\r\n      })\r\n      var r = derived;\r\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\r\n      return r;\r\n    } catch(e) {\r\n      console.log(e);\r\n      SEA.err = e;\r\n      if(SEA.throw){ throw e }\r\n      if(cb){ cb() }\r\n      return;\r\n    }});\r\n\r\n    // can this be replaced with settings.jwk?\r\n    var keysToEcdhJwk = (pub, d) => { // d === priv\r\n      //var [ x, y ] = shim.Buffer.from(pub, 'base64').toString('utf8').split(':') // old\r\n      var [ x, y ] = pub.split('.') // new\r\n      var jwk = d ? { d: d } : {}\r\n      return [  // Use with spread returned value...\r\n        'jwk',\r\n        Object.assign(\r\n          jwk,\r\n          { x: x, y: y, kty: 'EC', crv: 'P-256', ext: true }\r\n        ), // ??? refactor\r\n        {name: 'ECDH', namedCurve: 'P-256'}\r\n      ]\r\n    }\r\n\r\n    module.exports = SEA.secret;\r\n  })(USE, './secret');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./root');\r\n    // This is to certify that a group of \"certificants\" can \"put\" anything at a group of matched \"paths\" to the certificate authority's graph\r\n    SEA.certify = SEA.certify || (async (certificants, policy = {}, authority, cb, opt = {}) => { try {\r\n      /*\r\n      The Certify Protocol was made out of love by a Vietnamese code enthusiast. Vietnamese people around the world deserve respect!\r\n      IMPORTANT: A Certificate is like a Signature. No one knows who (authority) created/signed a cert until you put it into their graph.\r\n      \"certificants\": '*' or a String (Bob.pub) || an Object that contains \"pub\" as a key || an array of [object || string]. These people will have the rights.\r\n      \"policy\": A string ('inbox'), or a RAD/LEX object {'*': 'inbox'}, or an Array of RAD/LEX objects or strings. RAD/LEX object can contain key \"?\" with indexOf(\"*\") > -1 to force key equals certificant pub. This rule is used to check against soul+'/'+key using Gun.text.match or String.match.\r\n      \"authority\": Key pair or priv of the certificate authority.\r\n      \"cb\": A callback function after all things are done.\r\n      \"opt\": If opt.expiry (a timestamp) is set, SEA won't sync data after opt.expiry. If opt.block is set, SEA will look for block before syncing.\r\n      */\r\n      console.log('SEA.certify() is an early experimental community supported method that may change API behavior without warning in any future version.')\r\n\r\n      certificants = (() => {\r\n        var data = []\r\n        if (certificants) {\r\n          if ((typeof certificants === 'string' || Array.isArray(certificants)) && certificants.indexOf('*') > -1) return '*'\r\n          if (typeof certificants === 'string') return certificants\r\n          if (Array.isArray(certificants)) {\r\n            if (certificants.length === 1 && certificants[0]) return typeof certificants[0] === 'object' && certificants[0].pub ? certificants[0].pub : typeof certificants[0] === 'string' ? certificants[0] : null\r\n            certificants.map(certificant => {\r\n              if (typeof certificant ==='string') data.push(certificant)\r\n              else if (typeof certificant === 'object' && certificant.pub) data.push(certificant.pub)\r\n            })\r\n          }\r\n\r\n          if (typeof certificants === 'object' && certificants.pub) return certificants.pub\r\n          return data.length > 0 ? data : null\r\n        }\r\n        return\r\n      })()\r\n\r\n      if (!certificants) return console.log(\"No certificant found.\")\r\n\r\n      const expiry = opt.expiry && (typeof opt.expiry === 'number' || typeof opt.expiry === 'string') ? parseFloat(opt.expiry) : null\r\n      const readPolicy = (policy || {}).read ? policy.read : null\r\n      const writePolicy = (policy || {}).write ? policy.write : typeof policy === 'string' || Array.isArray(policy) || policy[\"+\"] || policy[\"#\"] || policy[\".\"] || policy[\"=\"] || policy[\"*\"] || policy[\">\"] || policy[\"<\"] ? policy : null\r\n      // The \"blacklist\" feature is now renamed to \"block\". Why ? BECAUSE BLACK LIVES MATTER!\r\n      // We can now use 3 keys: block, blacklist, ban\r\n      const block = (opt || {}).block || (opt || {}).blacklist || (opt || {}).ban || {}\r\n      const readBlock = block.read && (typeof block.read === 'string' || (block.read || {})['#']) ? block.read : null\r\n      const writeBlock = typeof block === 'string' ? block : block.write && (typeof block.write === 'string' || block.write['#']) ? block.write : null\r\n\r\n      if (!readPolicy && !writePolicy) return console.log(\"No policy found.\")\r\n\r\n      // reserved keys: c, e, r, w, rb, wb\r\n      const data = JSON.stringify({\r\n        c: certificants,\r\n        ...(expiry ? {e: expiry} : {}), // inject expiry if possible\r\n        ...(readPolicy ? {r: readPolicy }  : {}), // \"r\" stands for read, which means read permission.\r\n        ...(writePolicy ? {w: writePolicy} : {}), // \"w\" stands for write, which means write permission.\r\n        ...(readBlock ? {rb: readBlock} : {}), // inject READ block if possible\r\n        ...(writeBlock ? {wb: writeBlock} : {}), // inject WRITE block if possible\r\n      })\r\n\r\n      const certificate = await SEA.sign(data, authority, null, {raw:1})\r\n\r\n      var r = certificate\r\n      if(!opt.raw){ r = 'SEA'+JSON.stringify(r) }\r\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\r\n      return r;\r\n    } catch(e) {\r\n      SEA.err = e;\r\n      if(SEA.throw){ throw e }\r\n      if(cb){ cb() }\r\n      return;\r\n    }});\r\n\r\n    module.exports = SEA.certify;\r\n  })(USE, './certify');\r\n\r\n  ;USE(function(module){\r\n    var shim = USE('./shim');\r\n    // Practical examples about usage found in tests.\r\n    var SEA = USE('./root');\r\n    SEA.work = USE('./work');\r\n    SEA.sign = USE('./sign');\r\n    SEA.verify = USE('./verify');\r\n    SEA.encrypt = USE('./encrypt');\r\n    SEA.decrypt = USE('./decrypt');\r\n    SEA.certify = USE('./certify');\r\n    //SEA.opt.aeskey = USE('./aeskey'); // not official! // this causes problems in latest WebCrypto.\r\n\r\n    SEA.random = SEA.random || shim.random;\r\n\r\n    // This is Buffer used in SEA and usable from Gun/SEA application also.\r\n    // For documentation see https://nodejs.org/api/buffer.html\r\n    SEA.Buffer = SEA.Buffer || USE('./buffer');\r\n\r\n    // These SEA functions support now ony Promises or\r\n    // async/await (compatible) code, use those like Promises.\r\n    //\r\n    // Creates a wrapper library around Web Crypto API\r\n    // for various AES, ECDSA, PBKDF2 functions we called above.\r\n    // Calculate public key KeyID aka PGPv4 (result: 8 bytes as hex string)\r\n    SEA.keyid = SEA.keyid || (async (pub) => {\r\n      try {\r\n        // base64('base64(x):base64(y)') => shim.Buffer(xy)\r\n        const pb = shim.Buffer.concat(\r\n          pub.replace(/-/g, '+').replace(/_/g, '/').split('.')\r\n          .map((t) => shim.Buffer.from(t, 'base64'))\r\n        )\r\n        // id is PGPv4 compliant raw key\r\n        const id = shim.Buffer.concat([\r\n          shim.Buffer.from([0x99, pb.length / 0x100, pb.length % 0x100]), pb\r\n        ])\r\n        const sha1 = await sha1hash(id)\r\n        const hash = shim.Buffer.from(sha1, 'binary')\r\n        return hash.toString('hex', hash.length - 8)  // 16-bit ID as hex\r\n      } catch (e) {\r\n        console.log(e)\r\n        throw e\r\n      }\r\n    });\r\n    // all done!\r\n    // Obviously it is missing MANY necessary features. This is only an alpha release.\r\n    // Please experiment with it, audit what I've done so far, and complain about what needs to be added.\r\n    // SEA should be a full suite that is easy and seamless to use.\r\n    // Again, scroll naer the top, where I provide an EXAMPLE of how to create a user and sign in.\r\n    // Once logged in, the rest of the code you just read handled automatically signing/validating data.\r\n    // But all other behavior needs to be equally easy, like opinionated ways of\r\n    // Adding friends (trusted public keys), sending private messages, etc.\r\n    // Cheers! Tell me what you think.\r\n    ((SEA.window||{}).GUN||{}).SEA = SEA;\r\n\r\n    module.exports = SEA\r\n    // -------------- END SEA MODULES --------------------\r\n    // -- BEGIN SEA+GUN MODULES: BUNDLED BY DEFAULT UNTIL OTHERS USE SEA ON OWN -------\r\n  })(USE, './sea');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./sea'), Gun, u;\r\n    if(SEA.window){\r\n      Gun = SEA.window.GUN || {chain:{}};\r\n    } else {\r\n      Gun = USE((u+'' == typeof MODULE?'.':'')+'./gun', 1);\r\n    }\r\n    SEA.GUN = Gun;\r\n\r\n    function User(root){ \r\n      this._ = {$: this};\r\n    }\r\n    User.prototype = (function(){ function F(){}; F.prototype = Gun.chain; return new F() }()) // Object.create polyfill\r\n    User.prototype.constructor = User;\r\n\r\n    // let's extend the gun chain with a `user` function.\r\n    // only one user can be logged in at a time, per gun instance.\r\n    Gun.chain.user = function(pub){\r\n      var gun = this, root = gun.back(-1), user;\r\n      if(pub){\r\n        pub = SEA.opt.pub((pub._||'')['#']) || pub;\r\n        return root.get('~'+pub);\r\n      }\r\n      if(user = root.back('user')){ return user }\r\n      var root = (root._), at = root, uuid = at.opt.uuid || lex;\r\n      (at = (user = at.user = gun.chain(new User))._).opt = {};\r\n      at.opt.uuid = function(cb){\r\n        var id = uuid(), pub = root.user;\r\n        if(!pub || !(pub = pub.is) || !(pub = pub.pub)){ return id }\r\n        id = '~' + pub + '/' + id;\r\n        if(cb && cb.call){ cb(null, id) }\r\n        return id;\r\n      }\r\n      return user;\r\n    }\r\n    function lex(){ return Gun.state().toString(36).replace('.','') }\r\n    Gun.User = User;\r\n    User.GUN = Gun;\r\n    User.SEA = Gun.SEA = SEA;\r\n    module.exports = User;\r\n  })(USE, './user');\r\n\r\n  ;USE(function(module){\r\n    var u, Gun = (''+u != typeof window)? (window.Gun||{chain:{}}) : USE((''+u === typeof MODULE?'.':'')+'./gun', 1);\r\n    Gun.chain.then = function(cb, opt){\r\n      var gun = this, p = (new Promise(function(res, rej){\r\n        gun.once(res, opt);\r\n      }));\r\n      return cb? p.then(cb) : p;\r\n    }\r\n  })(USE, './then');\r\n\r\n  ;USE(function(module){\r\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\r\n\r\n    // Well first we have to actually create a user. That is what this function does.\r\n    User.prototype.create = function(...args){\r\n      var pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\r\n      var alias = pair && (pair.pub || pair.epub) ? pair.pub : typeof args[0] === 'string' ? args[0] : null;\r\n      var pass = pair && (pair.pub || pair.epub) ? pair : alias && typeof args[1] === 'string' ? args[1] : null;\r\n      var cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\r\n      var opt = args && args.length > 1 && typeof args[args.length-1] === 'object' ? args[args.length-1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\r\n      \r\n      var gun = this, cat = (gun._), root = gun.back(-1);\r\n      cb = cb || noop;\r\n      opt = opt || {};\r\n      if(false !== opt.check){\r\n        var err;\r\n        if(!alias){ err = \"No user.\" }\r\n        if((pass||'').length < 8){ err = \"Password too short!\" }\r\n        if(err){\r\n          cb({err: Gun.log(err)});\r\n          return gun;\r\n        }\r\n      }\r\n      if(cat.ing){\r\n        (cb || noop)({err: Gun.log(\"User is already being created or authenticated!\"), wait: true});\r\n        return gun;\r\n      }\r\n      cat.ing = true;\r\n      var act = {}, u;\r\n      act.a = function(pubs){\r\n        act.pubs = pubs;\r\n        if(pubs && !opt.already){\r\n          // If we can enforce that a user name is already taken, it might be nice to try, but this is not guaranteed.\r\n          var ack = {err: Gun.log('User already created!')};\r\n          cat.ing = false;\r\n          (cb || noop)(ack);\r\n          gun.leave();\r\n          return;\r\n        }\r\n        act.salt = String.random(64); // pseudo-randomly create a salt, then use PBKDF2 function to extend the password with it.\r\n        SEA.work(pass, act.salt, act.b); // this will take some short amount of time to produce a proof, which slows brute force attacks.\r\n      }\r\n      act.b = function(proof){\r\n        act.proof = proof;\r\n        pair ? act.c(pair) : SEA.pair(act.c) // generate a brand new key pair or use the existing.\r\n      }\r\n      act.c = function(pair){\r\n        var tmp\r\n        act.pair = pair || {};\r\n        if(tmp = cat.root.user){\r\n          tmp._.sea = pair;\r\n          tmp.is = {pub: pair.pub, epub: pair.epub, alias: alias};\r\n        }\r\n        // the user's public key doesn't need to be signed. But everything else needs to be signed with it! // we have now automated it! clean up these extra steps now!\r\n        act.data = {pub: pair.pub};\r\n        act.d();\r\n      }\r\n      act.d = function(){\r\n        act.data.alias = alias;\r\n        act.e();\r\n      }\r\n      act.e = function(){\r\n        act.data.epub = act.pair.epub; \r\n        SEA.encrypt({priv: act.pair.priv, epriv: act.pair.epriv}, act.proof, act.f, {raw:1}); // to keep the private key safe, we AES encrypt it with the proof of work!\r\n      }\r\n      act.f = function(auth){\r\n        act.data.auth = JSON.stringify({ek: auth, s: act.salt}); \r\n        act.g(act.data.auth);\r\n      }\r\n      act.g = function(auth){ var tmp;\r\n        act.data.auth = act.data.auth || auth;\r\n        root.get(tmp = '~'+act.pair.pub).put(act.data).on(act.h); // awesome, now we can actually save the user with their public key as their ID.\r\n        var link = {}; link[tmp] = {'#': tmp}; root.get('~@'+alias).put(link).get(tmp).on(act.i); // next up, we want to associate the alias with the public key. So we add it to the alias list.\r\n      }\r\n      act.h = function(data, key, msg, eve){\r\n        eve.off(); act.h.ok = 1; act.i();\r\n      }\r\n      act.i = function(data, key, msg, eve){\r\n        if(eve){ act.i.ok = 1; eve.off() }\r\n        if(!act.h.ok || !act.i.ok){ return }\r\n        cat.ing = false;\r\n        cb({ok: 0, pub: act.pair.pub}); // callback that the user has been created. (Note: ok = 0 because we didn't wait for disk to ack)\r\n        if(noop === cb){ pair ? gun.auth(pair) : gun.auth(alias, pass) } // if no callback is passed, auto-login after signing up.\r\n      }\r\n      root.get('~@'+alias).once(act.a);\r\n      return gun;\r\n    }\r\n    User.prototype.leave = function(opt, cb){\r\n      var gun = this, user = (gun.back(-1)._).user;\r\n      if(user){\r\n        delete user.is;\r\n        delete user._.is;\r\n        delete user._.sea;\r\n      }\r\n      if(SEA.window){\r\n        try{var sS = {};\r\n        sS = window.sessionStorage;\r\n        delete sS.recall;\r\n        delete sS.pair;\r\n        }catch(e){};\r\n      }\r\n      return gun;\r\n    }\r\n  })(USE, './create');\r\n\r\n  ;USE(function(module){\r\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\r\n    // now that we have created a user, we want to authenticate them!\r\n    User.prototype.auth = function(...args){ // TODO: this PR with arguments need to be cleaned up / refactored.\r\n      var pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\r\n      var alias = !pair && typeof args[0] === 'string' ? args[0] : null;\r\n      var pass = alias && typeof args[1] === 'string' ? args[1] : null;\r\n      var cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\r\n      var opt = args && args.length > 1 && typeof args[args.length-1] === 'object' ? args[args.length-1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\r\n      \r\n      var gun = this, cat = (gun._), root = gun.back(-1);\r\n      \r\n      if(cat.ing){\r\n        (cb || noop)({err: Gun.log(\"User is already being created or authenticated!\"), wait: true});\r\n        return gun;\r\n      }\r\n      cat.ing = true;\r\n      \r\n      var act = {}, u;\r\n      act.a = function(data){\r\n        if(!data){ return act.b() }\r\n        if(!data.pub){\r\n          var tmp = []; Object.keys(data).forEach(function(k){ if('_'==k){ return } tmp.push(data[k]) })\r\n          return act.b(tmp);\r\n        }\r\n        if(act.name){ return act.f(data) }\r\n        act.c((act.data = data).auth);\r\n      }\r\n      act.b = function(list){\r\n        var get = (act.list = (act.list||[]).concat(list||[])).shift();\r\n        if(u === get){\r\n          if(act.name){ return act.err('Your user account is not published for dApps to access, please consider syncing it online, or allowing local access by adding your device as a peer.') }\r\n          return act.err('Wrong user or password.') \r\n        }\r\n        root.get(get).once(act.a);\r\n      }\r\n      act.c = function(auth){\r\n        if(u === auth){ return act.b() }\r\n        if('string' == typeof auth){ return act.c(obj_ify(auth)) } // in case of legacy\r\n        SEA.work(pass, (act.auth = auth).s, act.d, act.enc); // the proof of work is evidence that we've spent some time/effort trying to log in, this slows brute force.\r\n      }\r\n      act.d = function(proof){\r\n        SEA.decrypt(act.auth.ek, proof, act.e, act.enc);\r\n      }\r\n      act.e = function(half){\r\n        if(u === half){\r\n          if(!act.enc){ // try old format\r\n            act.enc = {encode: 'utf8'};\r\n            return act.c(act.auth);\r\n          } act.enc = null; // end backwards\r\n          return act.b();\r\n        }\r\n        act.half = half;\r\n        act.f(act.data);\r\n      }\r\n      act.f = function(pair){\r\n        var half = act.half || {}, data = act.data || {};\r\n        act.g(act.lol = {pub: pair.pub || data.pub, epub: pair.epub || data.epub, priv: pair.priv || half.priv, epriv: pair.epriv || half.epriv});\r\n      }\r\n      act.g = function(pair){\r\n        if(!pair || !pair.pub || !pair.epub){ return act.b() }\r\n        act.pair = pair;\r\n        var user = (root._).user, at = (user._);\r\n        var tmp = at.tag;\r\n        var upt = at.opt;\r\n        at = user._ = root.get('~'+pair.pub)._;\r\n        at.opt = upt;\r\n        // add our credentials in-memory only to our root user instance\r\n        user.is = {pub: pair.pub, epub: pair.epub, alias: alias || pair.pub};\r\n        at.sea = act.pair;\r\n        cat.ing = false;\r\n        try{if(pass && u == (obj_ify(cat.root.graph['~'+pair.pub].auth)||'')[':']){ opt.shuffle = opt.change = pass; } }catch(e){} // migrate UTF8 & Shuffle!\r\n        opt.change? act.z() : (cb || noop)(at);\r\n        if(SEA.window && ((gun.back('user')._).opt||opt).remember){\r\n          // TODO: this needs to be modular.\r\n          try{var sS = {};\r\n          sS = window.sessionStorage; // TODO: FIX BUG putting on `.is`!\r\n          sS.recall = true;\r\n          sS.pair = JSON.stringify(pair); // auth using pair is more reliable than alias/pass\r\n          }catch(e){}\r\n        }\r\n        try{\r\n          if(root._.tag.auth){ // auth handle might not be registered yet\r\n          (root._).on('auth', at) // TODO: Deprecate this, emit on user instead! Update docs when you do.\r\n          } else { setTimeout(function(){ (root._).on('auth', at) },1) } // if not, hackily add a timeout.\r\n          //at.on('auth', at) // Arrgh, this doesn't work without event \"merge\" code, but \"merge\" code causes stack overflow and crashes after logging in & trying to write data.\r\n        }catch(e){\r\n          Gun.log(\"Your 'auth' callback crashed with:\", e);\r\n        }\r\n      }\r\n      act.z = function(){\r\n        // password update so encrypt private key using new pwd + salt\r\n        act.salt = String.random(64); // pseudo-random\r\n        SEA.work(opt.change, act.salt, act.y);\r\n      }\r\n      act.y = function(proof){\r\n        SEA.encrypt({priv: act.pair.priv, epriv: act.pair.epriv}, proof, act.x, {raw:1});\r\n      }\r\n      act.x = function(auth){\r\n        act.w(JSON.stringify({ek: auth, s: act.salt}));\r\n      }\r\n      act.w = function(auth){\r\n        if(opt.shuffle){ // delete in future!\r\n          console.log('migrate core account from UTF8 & shuffle');\r\n          var tmp = {}; Object.keys(act.data).forEach(function(k){ tmp[k] = act.data[k] });\r\n          delete tmp._;\r\n          tmp.auth = auth;\r\n          root.get('~'+act.pair.pub).put(tmp);\r\n        } // end delete\r\n        root.get('~'+act.pair.pub).get('auth').put(auth, cb || noop);\r\n      }\r\n      act.err = function(e){\r\n        var ack = {err: Gun.log(e || 'User cannot be found!')};\r\n        cat.ing = false;\r\n        (cb || noop)(ack);\r\n      }\r\n      act.plugin = function(name){\r\n        if(!(act.name = name)){ return act.err() }\r\n        var tmp = [name];\r\n        if('~' !== name[0]){\r\n          tmp[1] = '~'+name;\r\n          tmp[2] = '~@'+name;\r\n        }\r\n        act.b(tmp);\r\n      }\r\n      if(pair){\r\n        act.g(pair);\r\n      } else\r\n      if(alias){\r\n        root.get('~@'+alias).once(act.a);\r\n      } else\r\n      if(!alias && !pass){\r\n        SEA.name(act.plugin);\r\n      }\r\n      return gun;\r\n    }\r\n    function obj_ify(o){\r\n      if('string' != typeof o){ return o }\r\n      try{o = JSON.parse(o);\r\n      }catch(e){o={}};\r\n      return o;\r\n    }\r\n  })(USE, './auth');\r\n\r\n  ;USE(function(module){\r\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN;\r\n    User.prototype.recall = function(opt, cb){\r\n      var gun = this, root = gun.back(-1), tmp;\r\n      opt = opt || {};\r\n      if(opt && opt.sessionStorage){\r\n        if(SEA.window){\r\n          try{\r\n            var sS = {};\r\n            sS = window.sessionStorage; // TODO: FIX BUG putting on `.is`!\r\n            if(sS){\r\n              (root._).opt.remember = true;\r\n              ((gun.back('user')._).opt||opt).remember = true;\r\n              if(sS.recall || sS.pair) root.user().auth(JSON.parse(sS.pair), cb); // pair is more reliable than alias/pass\r\n            }\r\n          }catch(e){}\r\n        }\r\n        return gun;\r\n      }\r\n      /*\r\n        TODO: copy mhelander's expiry code back in.\r\n        Although, we should check with community,\r\n        should expiry be core or a plugin?\r\n      */\r\n      return gun;\r\n    }\r\n  })(USE, './recall');\r\n\r\n  ;USE(function(module){\r\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\r\n    User.prototype.pair = function(){\r\n      var user = this, proxy; // undeprecated, hiding with proxies.\r\n      try{ proxy = new Proxy({DANGER:'\\u2620'}, {get: function(t,p,r){\r\n        if(!user.is || !(user._||'').sea){ return }\r\n        return user._.sea[p];\r\n      }})}catch(e){}\r\n      return proxy;\r\n    }\r\n    // If authenticated user wants to delete his/her account, let's support it!\r\n    User.prototype.delete = async function(alias, pass, cb){\r\n      console.log(\"user.delete() IS DEPRECATED AND WILL BE MOVED TO A MODULE!!!\");\r\n      var gun = this, root = gun.back(-1), user = gun.back('user');\r\n      try {\r\n        user.auth(alias, pass, function(ack){\r\n          var pub = (user.is||{}).pub;\r\n          // Delete user data\r\n          user.map().once(function(){ this.put(null) });\r\n          // Wipe user data from memory\r\n          user.leave();\r\n          (cb || noop)({ok: 0});\r\n        });\r\n      } catch (e) {\r\n        Gun.log('User.delete failed! Error:', e);\r\n      }\r\n      return gun;\r\n    }\r\n    User.prototype.alive = async function(){\r\n      console.log(\"user.alive() IS DEPRECATED!!!\");\r\n      const gunRoot = this.back(-1)\r\n      try {\r\n        // All is good. Should we do something more with actual recalled data?\r\n        await authRecall(gunRoot)\r\n        return gunRoot._.user._\r\n      } catch (e) {\r\n        const err = 'No session!'\r\n        Gun.log(err)\r\n        throw { err }\r\n      }\r\n    }\r\n    User.prototype.trust = async function(user){\r\n      console.log(\"`.trust` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\r\n      // TODO: BUG!!! SEA `node` read listener needs to be async, which means core needs to be async too.\r\n      //gun.get('alice').get('age').trust(bob);\r\n      if (Gun.is(user)) {\r\n        user.get('pub').get((ctx, ev) => {\r\n          console.log(ctx, ev)\r\n        })\r\n      }\r\n      user.get('trust').get(path).put(theirPubkey);\r\n\r\n      // do a lookup on this gun chain directly (that gets bob's copy of the data)\r\n      // do a lookup on the metadata trust table for this path (that gets all the pubkeys allowed to write on this path)\r\n      // do a lookup on each of those pubKeys ON the path (to get the collab data \"layers\")\r\n      // THEN you perform Jachen's mix operation\r\n      // and return the result of that to...\r\n    }\r\n    User.prototype.grant = function(to, cb){\r\n      console.log(\"`.grant` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\r\n      var gun = this, user = gun.back(-1).user(), pair = user._.sea, path = '';\r\n      gun.back(function(at){ if(at.is){ return } path += (at.get||'') });\r\n      (async function(){\r\n      var enc, sec = await user.get('grant').get(pair.pub).get(path).then();\r\n      sec = await SEA.decrypt(sec, pair);\r\n      if(!sec){\r\n        sec = SEA.random(16).toString();\r\n        enc = await SEA.encrypt(sec, pair);\r\n        user.get('grant').get(pair.pub).get(path).put(enc);\r\n      }\r\n      var pub = to.get('pub').then();\r\n      var epub = to.get('epub').then();\r\n      pub = await pub; epub = await epub;\r\n      var dh = await SEA.secret(epub, pair);\r\n      enc = await SEA.encrypt(sec, dh);\r\n      user.get('grant').get(pub).get(path).put(enc, cb);\r\n      }());\r\n      return gun;\r\n    }\r\n    User.prototype.secret = function(data, cb){\r\n      console.log(\"`.secret` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\r\n      var gun = this, user = gun.back(-1).user(), pair = user.pair(), path = '';\r\n      gun.back(function(at){ if(at.is){ return } path += (at.get||'') });\r\n      (async function(){\r\n      var enc, sec = await user.get('trust').get(pair.pub).get(path).then();\r\n      sec = await SEA.decrypt(sec, pair);\r\n      if(!sec){\r\n        sec = SEA.random(16).toString();\r\n        enc = await SEA.encrypt(sec, pair);\r\n        user.get('trust').get(pair.pub).get(path).put(enc);\r\n      }\r\n      enc = await SEA.encrypt(data, sec);\r\n      gun.put(enc, cb);\r\n      }());\r\n      return gun;\r\n    }\r\n\r\n    /**\r\n     * returns the decrypted value, encrypted by secret\r\n     * @returns {Promise<any>}\r\n     // Mark needs to review 1st before officially supported\r\n    User.prototype.decrypt = function(cb) {\r\n      let gun = this,\r\n        path = ''\r\n      gun.back(function(at) {\r\n        if (at.is) {\r\n          return\r\n        }\r\n        path += at.get || ''\r\n      })\r\n      return gun\r\n        .then(async data => {\r\n          if (data == null) {\r\n            return\r\n          }\r\n          const user = gun.back(-1).user()\r\n          const pair = user.pair()\r\n          let sec = await user\r\n            .get('trust')\r\n            .get(pair.pub)\r\n            .get(path)\r\n          sec = await SEA.decrypt(sec, pair)\r\n          if (!sec) {\r\n            return data\r\n          }\r\n          let decrypted = await SEA.decrypt(data, sec)\r\n          return decrypted\r\n        })\r\n        .then(res => {\r\n          cb && cb(res)\r\n          return res\r\n        })\r\n    }\r\n    */\r\n    module.exports = User\r\n  })(USE, './share');\r\n\r\n  ;USE(function(module){\r\n    var SEA = USE('./sea'), S = USE('./settings'), noop = function() {}, u;\r\n    var Gun = (''+u != typeof window)? (window.Gun||{on:noop}) : USE((''+u === typeof MODULE?'.':'')+'./gun', 1);\r\n    // After we have a GUN extension to make user registration/login easy, we then need to handle everything else.\r\n\r\n    // We do this with a GUN adapter, we first listen to when a gun instance is created (and when its options change)\r\n    Gun.on('opt', function(at){\r\n      if(!at.sea){ // only add SEA once per instance, on the \"at\" context.\r\n        at.sea = {own: {}};\r\n        at.on('put', check, at); // SEA now runs its firewall on HAM diffs, not all i/o.\r\n      }\r\n      this.to.next(at); // make sure to call the \"next\" middleware adapter.\r\n    });\r\n\r\n    // Alright, this next adapter gets run at the per node level in the graph database.\r\n    // correction: 2020 it gets run on each key/value pair in a node upon a HAM diff.\r\n    // This will let us verify that every property on a node has a value signed by a public key we trust.\r\n    // If the signature does not match, the data is just `undefined` so it doesn't get passed on.\r\n    // If it does match, then we transform the in-memory \"view\" of the data into its plain value (without the signature).\r\n    // Now NOTE! Some data is \"system\" data, not user data. Example: List of public keys, aliases, etc.\r\n    // This data is self-enforced (the value can only match its ID), but that is handled in the `security` function.\r\n    // From the self-enforced data, we can see all the edges in the graph that belong to a public key.\r\n    // Example: ~ASDF is the ID of a node with ASDF as its public key, signed alias and salt, and\r\n    // its encrypted private key, but it might also have other signed values on it like `profile = <ID>` edge.\r\n    // Using that directed edge's ID, we can then track (in memory) which IDs belong to which keys.\r\n    // Here is a problem: Multiple public keys can \"claim\" any node's ID, so this is dangerous!\r\n    // This means we should ONLY trust our \"friends\" (our key ring) public keys, not any ones.\r\n    // I have not yet added that to SEA yet in this alpha release. That is coming soon, but beware in the meanwhile!\r\n\r\n    function check(msg){ // REVISE / IMPROVE, NO NEED TO PASS MSG/EVE EACH SUB?\r\n      var eve = this, at = eve.as, put = msg.put, soul = put['#'], key = put['.'], val = put[':'], state = put['>'], id = msg['#'], tmp;\r\n      if(!soul || !key){ return }\r\n      if((msg._||'').faith && (at.opt||'').faith && 'function' == typeof msg._){\r\n        SEA.opt.pack(put, function(raw){\r\n        SEA.verify(raw, false, function(data){ // this is synchronous if false\r\n          put['='] = SEA.opt.unpack(data);\r\n          eve.to.next(msg);\r\n        })})\r\n        return \r\n      }\r\n      var no = function(why){ at.on('in', {'@': id, err: msg.err = why}) }; // exploit internal relay stun for now, maybe violates spec, but testing for now. // Note: this may be only the sharded message, not original batch.\r\n      //var no = function(why){ msg.ack(why) };\r\n      (msg._||'').DBG && ((msg._||'').DBG.c = +new Date);\r\n      if(0 <= soul.indexOf('<?')){ // special case for \"do not sync data X old\" forget\r\n        // 'a~pub.key/b<?9'\r\n        tmp = parseFloat(soul.split('<?')[1]||'');\r\n        if(tmp && (state < (Gun.state() - (tmp * 1000)))){ // sec to ms\r\n          (tmp = msg._) && (tmp.stun) && (tmp.stun--); // THIS IS BAD CODE! It assumes GUN internals do something that will probably change in future, but hacking in now.\r\n          return; // omit!\r\n        }\r\n      }\r\n      \r\n      if('~@' === soul){  // special case for shared system data, the list of aliases.\r\n        check.alias(eve, msg, val, key, soul, at, no); return;\r\n      }\r\n      if('~@' === soul.slice(0,2)){ // special case for shared system data, the list of public keys for an alias.\r\n        check.pubs(eve, msg, val, key, soul, at, no); return;\r\n      }\r\n      //if('~' === soul.slice(0,1) && 2 === (tmp = soul.slice(1)).split('.').length){ // special case, account data for a public key.\r\n      if(tmp = SEA.opt.pub(soul)){ // special case, account data for a public key.\r\n        check.pub(eve, msg, val, key, soul, at, no, at.user||'', tmp); return;\r\n      }\r\n      if(0 <= soul.indexOf('#')){ // special case for content addressing immutable hashed data.\r\n        check.hash(eve, msg, val, key, soul, at, no); return;\r\n      } \r\n      check.any(eve, msg, val, key, soul, at, no, at.user||''); return;\r\n      eve.to.next(msg); // not handled\r\n    }\r\n    check.hash = function(eve, msg, val, key, soul, at, no){\r\n      SEA.work(val, null, function(data){\r\n        if(data && data === key.split('#').slice(-1)[0]){ return eve.to.next(msg) }\r\n        no(\"Data hash not same as hash!\");\r\n      }, {name: 'SHA-256'});\r\n    }\r\n    check.alias = function(eve, msg, val, key, soul, at, no){ // Example: {_:#~@, ~@alice: {#~@alice}}\r\n      if(!val){ return no(\"Data must exist!\") } // data MUST exist\r\n      if('~@'+key === link_is(val)){ return eve.to.next(msg) } // in fact, it must be EXACTLY equal to itself\r\n      no(\"Alias not same!\"); // if it isn't, reject.\r\n    };\r\n    check.pubs = function(eve, msg, val, key, soul, at, no){ // Example: {_:#~@alice, ~asdf: {#~asdf}}\r\n      if(!val){ return no(\"Alias must exist!\") } // data MUST exist\r\n      if(key === link_is(val)){ return eve.to.next(msg) } // and the ID must be EXACTLY equal to its property\r\n      no(\"Alias not same!\"); // that way nobody can tamper with the list of public keys.\r\n    };\r\n    check.pub = async function(eve, msg, val, key, soul, at, no, user, pub){ var tmp // Example: {_:#~asdf, hello:'world'~fdsa}}\r\n      const raw = await S.parse(val) || {}\r\n      const verify = (certificate, certificant, cb) => {\r\n        if (certificate.m && certificate.s && certificant && pub)\r\n          // now verify certificate\r\n          return SEA.verify(certificate, pub, data => { // check if \"pub\" (of the graph owner) really issued this cert\r\n            if (u !== data && u !== data.e && msg.put['>'] && msg.put['>'] > parseFloat(data.e)) return no(\"Certificate expired.\") // certificate expired\r\n            // \"data.c\" = a list of certificants/certified users\r\n            // \"data.w\" = lex WRITE permission, in the future, there will be \"data.r\" which means lex READ permission\r\n            if (u !== data && data.c && data.w && (data.c === certificant || data.c.indexOf('*' || certificant) > -1)) {\r\n              // ok, now \"certificant\" is in the \"certificants\" list, but is \"path\" allowed? Check path\r\n              let path = soul.indexOf('/') > -1 ? soul.replace(soul.substring(0, soul.indexOf('/') + 1), '') : ''\r\n              String.match = String.match || Gun.text.match\r\n              const w = Array.isArray(data.w) ? data.w : typeof data.w === 'object' || typeof data.w === 'string' ? [data.w] : []\r\n              for (const lex of w) {\r\n                if ((String.match(path, lex['#']) && String.match(key, lex['.'])) || (!lex['.'] && String.match(path, lex['#'])) || (!lex['#'] && String.match(key, lex['.'])) || String.match((path ? path + '/' + key : key), lex['#'] || lex)) {\r\n                  // is Certificant forced to present in Path\r\n                  if (lex['+'] && lex['+'].indexOf('*') > -1 && path && path.indexOf(certificant) == -1 && key.indexOf(certificant) == -1) return no(`Path \"${path}\" or key \"${key}\" must contain string \"${certificant}\".`)\r\n                  // path is allowed, but is there any WRITE block? Check it out\r\n                  if (data.wb && (typeof data.wb === 'string' || ((data.wb || {})['#']))) { // \"data.wb\" = path to the WRITE block\r\n                    var root = eve.as.root.$.back(-1)\r\n                    if (typeof data.wb === 'string' && '~' !== data.wb.slice(0, 1)) root = root.get('~' + pub)\r\n                    return root.get(data.wb).get(certificant).once(value => {\r\n                      if (value && (value === 1 || value === true)) return no(`Certificant ${certificant} blocked.`)\r\n                      return cb(data)\r\n                    })\r\n                  }\r\n                  return cb(data)\r\n                }\r\n              }\r\n              return no(\"Certificate verification fail.\")\r\n            }\r\n          })\r\n        return\r\n      }\r\n      \r\n      if ('pub' === key && '~' + pub === soul) {\r\n        if (val === pub) return eve.to.next(msg) // the account MUST match `pub` property that equals the ID of the public key.\r\n        return no(\"Account not same!\")\r\n      }\r\n\r\n      if ((tmp = user.is) && tmp.pub && !raw['*'] && !raw['+'] && (pub === tmp.pub || (pub !== tmp.pub && ((msg._.msg || {}).opt || {}).cert))){\r\n        SEA.opt.pack(msg.put, packed => {\r\n          SEA.sign(packed, (user._).sea, async function(data) {\r\n            if (u === data) return no(SEA.err || 'Signature fail.')\r\n            msg.put[':'] = {':': tmp = SEA.opt.unpack(data.m), '~': data.s}\r\n            msg.put['='] = tmp\r\n  \r\n            // if writing to own graph, just allow it\r\n            if (pub === user.is.pub) {\r\n              if (tmp = link_is(val)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1\r\n              JSON.stringifyAsync(msg.put[':'], function(err,s){\r\n                if(err){ return no(err || \"Stringify error.\") }\r\n                msg.put[':'] = s;\r\n                return eve.to.next(msg);\r\n              })\r\n              return\r\n            }\r\n  \r\n            // if writing to other's graph, check if cert exists then try to inject cert into put, also inject self pub so that everyone can verify the put\r\n            if (pub !== user.is.pub && ((msg._.msg || {}).opt || {}).cert) {\r\n              const cert = await S.parse(msg._.msg.opt.cert)\r\n              // even if cert exists, we must verify it\r\n              if (cert && cert.m && cert.s)\r\n                verify(cert, user.is.pub, _ => {\r\n                  msg.put[':']['+'] = cert // '+' is a certificate\r\n                  msg.put[':']['*'] = user.is.pub // '*' is pub of the user who puts\r\n                  JSON.stringifyAsync(msg.put[':'], function(err,s){\r\n                    if(err){ return no(err || \"Stringify error.\") }\r\n                    msg.put[':'] = s;\r\n                    return eve.to.next(msg);\r\n                  })\r\n                  return\r\n                })\r\n            }\r\n          }, {raw: 1})\r\n        })\r\n        return;\r\n      }\r\n\r\n      SEA.opt.pack(msg.put, packed => {\r\n        SEA.verify(packed, raw['*'] || pub, function(data){ var tmp;\r\n          data = SEA.opt.unpack(data);\r\n          if (u === data) return no(\"Unverified data.\") // make sure the signature matches the account it claims to be on. // reject any updates that are signed with a mismatched account.\r\n          if ((tmp = link_is(data)) && pub === SEA.opt.pub(tmp)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1\r\n          \r\n          // check if cert ('+') and putter's pub ('*') exist\r\n          if (raw['+'] && raw['+']['m'] && raw['+']['s'] && raw['*'])\r\n            // now verify certificate\r\n            verify(raw['+'], raw['*'], _ => {\r\n              msg.put['='] = data;\r\n              return eve.to.next(msg);\r\n            })\r\n          else {\r\n            msg.put['='] = data;\r\n            return eve.to.next(msg);\r\n          }\r\n        });\r\n      })\r\n      return\r\n    };\r\n    check.any = function(eve, msg, val, key, soul, at, no, user){ var tmp, pub;\r\n      if(at.opt.secure){ return no(\"Soul missing public key at '\" + key + \"'.\") }\r\n      // TODO: Ask community if should auto-sign non user-graph data.\r\n      at.on('secure', function(msg){ this.off();\r\n        if(!at.opt.secure){ return eve.to.next(msg) }\r\n        no(\"Data cannot be changed.\");\r\n      }).on.on('secure', msg);\r\n      return;\r\n    }\r\n\r\n    var valid = Gun.valid, link_is = function(d,l){ return 'string' == typeof (l = valid(d)) && l }, state_ify = (Gun.state||'').ify;\r\n\r\n    var pubcut = /[^\\w_-]/; // anything not alphanumeric or _ -\r\n    SEA.opt.pub = function(s){\r\n      if(!s){ return }\r\n      s = s.split('~');\r\n      if(!s || !(s = s[1])){ return }\r\n      s = s.split(pubcut).slice(0,2);\r\n      if(!s || 2 != s.length){ return }\r\n      if('@' === (s[0]||'')[0]){ return }\r\n      s = s.slice(0,2).join('.');\r\n      return s;\r\n    }\r\n    SEA.opt.stringy = function(t){\r\n      // TODO: encrypt etc. need to check string primitive. Make as breaking change.\r\n    }\r\n    SEA.opt.pack = function(d,cb,k, n,s){ var tmp, f; // pack for verifying\r\n      if(SEA.opt.check(d)){ return cb(d) }\r\n      if(d && d['#'] && d['.'] && d['>']){ tmp = d[':']; f = 1 }\r\n      JSON.parseAsync(f? tmp : d, function(err, meta){\r\n        var sig = ((u !== (meta||'')[':']) && (meta||'')['~']); // or just ~ check?\r\n        if(!sig){ cb(d); return }\r\n        cb({m: {'#':s||d['#'],'.':k||d['.'],':':(meta||'')[':'],'>':d['>']||Gun.state.is(n, k)}, s: sig});\r\n      });\r\n    }\r\n    var O = SEA.opt;\r\n    SEA.opt.unpack = function(d, k, n){ var tmp;\r\n      if(u === d){ return }\r\n      if(d && (u !== (tmp = d[':']))){ return tmp }\r\n      k = k || O.fall_key; if(!n && O.fall_val){ n = {}; n[k] = O.fall_val }\r\n      if(!k || !n){ return }\r\n      if(d === n[k]){ return d }\r\n      if(!SEA.opt.check(n[k])){ return d }\r\n      var soul = (n && n._ && n._['#']) || O.fall_soul, s = Gun.state.is(n, k) || O.fall_state;\r\n      if(d && 4 === d.length && soul === d[0] && k === d[1] && fl(s) === fl(d[3])){\r\n        return d[2];\r\n      }\r\n      if(s < SEA.opt.shuffle_attack){\r\n        return d;\r\n      }\r\n    }\r\n    SEA.opt.shuffle_attack = 1546329600000; // Jan 1, 2019\r\n    var fl = Math.floor; // TODO: Still need to fix inconsistent state issue.\r\n    // TODO: Potential bug? If pub/priv key starts with `-`? IDK how possible.\r\n\r\n  })(USE, './index');\r\n}());\r\n"]},"metadata":{},"sourceType":"script"}